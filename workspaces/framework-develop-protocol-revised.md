# FRAMEWORK-DEVELOP-PROTOCOL-REVISED

Execute rapid test-driven development cycles to actively fix and improve framework issues from a development cycle index, optimized purely for MVP development with aggressive iteration, breaking changes welcomed, and zero compatibility constraints. Focus on fixing problems rather than deprecating functionality.

## Protocol Activation

```text
@FRAMEWORK_DEVELOP execute <framework_dir> <development_cycle_index> <session_template>
```

**MVP-First Development Philosophy:**
- Zero compatibility constraints - breaking changes are welcomed and encouraged
- No versioning considerations - focus purely on current MVP needs
- No migration paths - optimize for simplicity over backward compatibility
- Fix don't deprecate - transform problematic code into better solutions
- Active improvement mindset - every problem gets fixed, not marked obsolete
- Direct execution from development cycle index (generated by requirements protocol)
- Aggressive development embracing breaking changes for MVP simplicity
- Rapid iteration cycles optimized for MVP feature development
- Simplified session management focused on delivery speed

## Command

### Execute - Rapid TDD Development from Cycle Index

The execute command performs aggressive TDD development directly from a development cycle index. Optimized for MVP context with minimal overhead:

1. Loads development cycle index with phase-organized requirements
2. Identifies current development phase and available requirements
3. Executes rapid TDD cycles for MVP development:
   - RED: Write focused failing test
   - GREEN: Implement minimal viable solution
   - REFACTOR: Optimize for clarity and performance
4. Documents development decisions and patterns discovered
5. Updates cycle index with phase progress
6. Continues until phase complete or natural breakpoint reached

```bash
@FRAMEWORK_DEVELOP execute \
  /path/to/AxiomFramework \
  /path/to/DEVELOPMENT-CYCLE-INDEX.md \
  /path/to/framework-session-template.md
```

### MVP Development Approach

This protocol **executes rapid TDD development optimized purely for MVP iteration**:
- Writes focused failing tests that validate MVP requirements
- Implements minimal viable solutions that pass tests
- Refactors aggressively with breaking changes welcomed for simplicity
- Eliminates all compatibility concerns in favor of MVP clarity
- Measures real performance and usability improvements for MVP use cases
- Documents patterns and decisions for rapid iteration
- Produces working MVP-ready framework code with zero legacy constraints

### Fix Don't Deprecate Principle

**Core Philosophy**: Every problematic API, pattern, or implementation gets actively fixed and transformed into a better solution. We never just mark things as deprecated or obsolete.

**In Practice**:
- Duplicate code â†’ Fixed by extracting clean abstractions
- Complex APIs â†’ Fixed by simplifying to MVP essentials
- Performance bottlenecks â†’ Fixed through targeted optimization
- Inconsistent patterns â†’ Fixed by standardizing across framework
- Over-engineered solutions â†’ Fixed by removing unnecessary layers
- Confusing interfaces â†’ Fixed by redesigning for clarity

**Why This Matters for MVP**:
- Deprecation leaves problems unsolved and creates technical debt
- Fixing transforms the framework into a better tool immediately
- MVP developers get clean, working solutions instead of warnings
- Every session improves the framework rather than just marking issues

### Work Types Supported

**Implementation Work** (MVP feature development):
- Adding core MVP capabilities with minimal API surface
- Resolving critical developer friction blocking MVP progress
- Implementing essential functionality with aggressive simplification

**Refactoring Work** (MVP optimization through fixing):
- Fixing duplicate code by consolidating into clean abstractions
- Fixing complex implementations through aggressive simplification
- Fixing over-engineering by removing unnecessary abstractions
- Fixing inconsistent patterns by standardizing for MVP clarity
- Fixing performance bottlenecks through targeted optimization
- Note: Always fix rather than deprecate - transform problematic code into better solutions

### Example Usage

```bash
@FRAMEWORK_DEVELOP execute \
  /Users/tojkuv/Documents/GitHub/axiom-apple/workspace-framework/AxiomFramework \
  /Users/tojkuv/Documents/GitHub/axiom-apple/workspace-framework/AxiomFramework/DEVELOPMENT-CYCLE-INDEX.md \
  /Users/tojkuv/Documents/GitHub/axiom-apple/workspace-meta-workspace/workspaces/framework-session-template.md
```

## Process Flow

```text
1. Load development cycle index to identify current phase and requirements
2. Check for existing session progress within current phase
3. Execute rapid TDD cycles optimized for MVP development:
   
   IMPLEMENTATION (MVP features):
   - RED: Write focused test validating MVP behavior
   - GREEN: Implement minimal viable solution
   - REFACTOR: Optimize for clarity and MVP performance
   
   REFACTORING (MVP fixing and optimization):
   - RED: Write preservation tests for critical behavior
   - GREEN: Fix problematic code through aggressive simplification
   - REFACTOR: Transform and improve for MVP maintainability
   - Focus: Fix issues at their root rather than marking as deprecated
   
4. Document development patterns and decisions immediately
5. Update cycle index with phase progress and insights
6. Continue until phase milestone reached or natural breakpoint
```

## Development Cycle Index Format

The protocol works directly with the development cycle index generated by the requirements protocol:

```markdown
# DEVELOPMENT-CYCLE-INDEX

## Executive Summary
- 7 requirements generated from 3 improvement areas
- 3 development phases identified
- Estimated timeline: 6 weeks MVP development

## Current Phase Status
**Phase 1: Foundation** - IN PROGRESS
**Phase 2: Infrastructure** - PENDING
**Phase 3: Integration** - PENDING

## Implementation Roadmap

### Phase 1: Foundation (Weeks 1-2) - CURRENT
- REQUIREMENTS-001-STATE-PERSISTENCE-CAPABILITY [COMPLETED]
- REQUIREMENTS-002-STATE-UPDATE-OPTIMIZATION [IN PROGRESS]
- Dependencies: None
- Exit Criteria: Core state management enhanced
- MVP Focus: Essential state handling for application needs

### Phase 2: Infrastructure (Weeks 3-4)
- REQUIREMENTS-004-TEST-BUILDER-PATTERN
- REQUIREMENTS-005-ASYNC-TEST-UTILITIES
- Dependencies: Phase 1 complete
- Exit Criteria: Testing framework supports MVP development velocity
- MVP Focus: Testing infrastructure that accelerates development

### Phase 3: Integration (Weeks 5-6)
- REQUIREMENTS-003-STATE-DEBUGGING-UTILITIES
- REQUIREMENTS-006-NATIVE-ASYNC-AWAIT
- REQUIREMENTS-007-ASYNC-STATE-COORDINATION
- Dependencies: Phases 1-2 complete
- Exit Criteria: Full MVP capability integration achieved
- MVP Focus: Production-ready integration and debugging

## Development Session History
- FW-SESSION-001.md [COMPLETED] - Phase 1 start
- FW-SESSION-002.md [COMPLETED] - REQUIREMENTS-001 completion
- FW-SESSION-003.md [IN PROGRESS] - REQUIREMENTS-002 development

## Next Session Plan
**Target**: Complete REQUIREMENTS-002, advance Phase 1 toward completion
**Estimated Duration**: 2-3 hours
**MVP Priority**: Unlock Phase 2 testing infrastructure development
```

## Phase-Driven Development Process

The execute command performs rapid TDD development organized by development phases:

### 1. Session Initialization

```
Loading development cycle index...
âœ“ Found 3 phases with 7 total requirements
âœ“ Current Phase: Phase 1 (Foundation) - 1/2 requirements completed
âœ“ Phase Progress: REQUIREMENTS-001 [COMPLETED], REQUIREMENTS-002 [IN PROGRESS]

Checking session history...
âœ“ Found existing sessions: FW-SESSION-001.md, FW-SESSION-002.md
âœ“ This will be: FW-SESSION-003.md

Planning current session...
âœ“ Phase 1 Focus: Complete REQUIREMENTS-002-STATE-UPDATE-OPTIMIZATION
âœ“ Dependencies: None (REQUIREMENTS-001 completed)
âœ“ MVP Priority: Critical for Phase 2 entry
âœ“ Estimated work: 2-3 hours MVP development
âœ“ Session goal: Complete Phase 1, unlock Phase 2 development

OR (if starting fresh)

âœ— No existing sessions found
âœ“ This will be: FW-SESSION-001.md (beginning Phase 1 development)
âœ“ Starting Phase 1: REQUIREMENTS-001-STATE-PERSISTENCE-CAPABILITY
âœ“ MVP Focus: Essential state management foundation
```

### 2. Phase-Driven Analysis

**Development Cycle Processing:**
- **Phase Structure**: Parse current phase requirements and dependencies
- **Progress Tracking**: Identify phase completion status and blocking issues
- **MVP Prioritization**: Focus on requirements critical for MVP functionality
- **Session Scope**: Target phase milestones and natural breakpoints

**Per-Requirement Analysis (for current session scope):**

**For Implementation Requirements (MVP Features):**
- **MVP Pain Points**: Extract critical friction blocking MVP development
- **Minimal API Design**: Design simplest viable interfaces
- **MVP Success Criteria**: Focus on essential functionality validation
- **Focused Testing**: Test core behavior without exhaustive edge cases

**For Refactoring Requirements (MVP Fixing and Optimization):**
- **Fix Code Complexity**: Target and fix complexity that slows MVP development
- **Fix Over-Engineering**: Preserve only functionality needed for MVP, fix the rest
- **Fix Through Consolidation**: Aggressively fix duplications and inconsistencies
- **Transformation Testing**: Test that fixes preserve essential behavior
- **Active Improvement**: Transform problematic code into clean solutions, never just deprecate

### 3. TDD Cycle Execution

#### RED Phase Execution

**Implementation Example:**
```
Starting RED Phase for MVP State Persistence...

Writing focused MVP test in Tests/StateTests/PersistenceTests.swift:
func testMVPStatePersistence() async throws {
    let stateManager = StateManager()
    await stateManager.setState("mvp_key", value: "mvp_data")
    // MVP requirement: basic persistence checking
    XCTAssertTrue(stateManager.isPersisted("mvp_key"))
}

Running swift test...
âœ— Test failed as expected: isPersisted method doesn't exist

Session file updated with MVP RED phase progress
```

**Refactoring Example:**
```
Starting RED Phase for MVP State Update Consolidation...

Writing essential behavior tests in Tests/StateTests/MVPBehaviorTests.swift:
func testMVPStateUpdateBehaviorPreserved() {
    // Test critical MVP state update patterns only
    let manager = StateManager()
    // Focus on behavior needed for MVP applications
}

Running swift test...
âœ“ All MVP behavior tests pass

Session file updated with MVP behavior preservation
```

#### GREEN Phase Execution

**Implementation Example:**
```
Starting GREEN Phase...

Implementing minimal viable solution in Sources/State/PersistenceManager.swift:
extension StateManager {
    func isPersisted(_ key: String) -> Bool {
        // MVP implementation: simple, focused, working
        return persistentStore.contains(key)
    }
}

Running swift test...
âœ“ MVP test passes with minimal implementation

Session file updated with MVP GREEN phase completion
```

**Refactoring Example:**
```
Starting GREEN Phase...

Aggressively fixing StateUpdateManager.swift for MVP:
- Fixed duplication by extracting MVPStateUpdatePattern protocol
- Fixed 5 duplicate implementations by consolidating into simple shared protocol
- Fixed bloat by reducing file from 200 lines to 50 lines (75% reduction)
- Fixed over-engineering by removing compatibility layers
- All problems actively fixed, nothing deprecated or left broken

Running swift test...
âœ“ All MVP behavior tests still pass
âœ“ Code dramatically simplified for MVP development

Session file updated with aggressive refactoring metrics
```

#### REFACTOR Phase Execution

**Implementation Example:**
```
Starting REFACTOR Phase...

Optimizing for MVP development velocity:
protocol MVPPersistenceProvider {
    func store(_ key: String, value: Any)
    func retrieve(_ key: String) -> Any?
    func contains(_ key: String) -> Bool
}

Running swift test...
âœ“ All MVP tests still passing
Running performance benchmarks...
âœ“ Performance improved by 15%
âœ“ Developer experience simplified for MVP use cases

Session file updated with MVP optimization results
```

**Refactoring Example:**
```
Starting REFACTOR Phase...

Further optimizing for MVP development:
- Added protocol extensions for MVP common cases
- Improved performance by 25%
- Simplified error handling for MVP debugging
- Removed unnecessary abstractions

All MVP tests still passing âœ“
Code complexity reduced by 40%
MVP developer experience significantly improved

Session updated: Documented MVP optimizations and velocity improvements
```

### 4. Session Documentation

Throughout execution, the session file documents actual fixes and improvements:
- Real TDD cycle progress and timings for each fix
- Actual code written to fix issues during implementation
- Transformative refactoring that fixes problems rather than deprecating
- Design decisions made to create better solutions
- Real performance metrics showing problems fixed
- Insights discovered about how to fix similar issues in future
- For refactoring: actual before/after code showing transformation, not deprecation

### Example Output

**Multi-Requirement Session:**
```
Executing Phase-Driven MVP Development...

Session: FW-SESSION-003.md
Phase 1 Progress: 1/2 requirements completed
Current Focus: Complete REQUIREMENTS-002 to unlock Phase 2

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ REQUIREMENTS-002: STATE-UPDATE-OPTIMIZATION â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â•â•â• RED PHASE: MVP Behavior Tests â•â•â•
Writing essential MVP behavior tests... Done
Running tests... All Pass
Time: 2m 45s

â•â•â• GREEN PHASE: Aggressive Consolidation â•â•â•
Consolidating 5 duplicate implementations... Done
Running tests... All Still Pass
Time: 8m 15s
Refactoring: 200 lines â†’ 50 lines (75% reduction)
MVP Focus: Simplified for rapid development

â•â•â• REFACTOR PHASE: MVP Optimization â•â•â•
Optimizing for MVP development velocity... Done
All tests passing âœ“
Time: 6m 30s
Developer experience significantly improved

âœ“ REQUIREMENTS-002 COMPLETED!
âœ“ PHASE 1 FOUNDATION COMPLETE!

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PHASE 2: INFRASTRUCTURE DEVELOPMENT READY   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â•â•â• PHASE 1 COMPLETION VALIDATION â•â•â•
Validating Phase 1 exit criteria... Done
All Phase 1 requirements completed âœ“
Core state management enhanced âœ“
MVP foundation solid âœ“

â•â•â• PHASE 2 ENTRY CONDITIONS â•â•â•
Checking Phase 2 dependencies... Satisfied âœ“
Phase 2 requirements available for development
Next session focus: Testing infrastructure

â–¶ Phase 1 complete, ready for Phase 2 initiation

Phase 1 Complete!
Generated: AxiomFramework/FW-SESSION-003.md
Total Duration: 1.8 hours
Completed: REQUIREMENTS-002 (MVP OPTIMIZATION)
Phase Status: PHASE 1 FOUNDATION [COMPLETED] âœ“
Overall Cycle Progress: Phase 1 complete, Phase 2 ready
Next Session: Begin Phase 2 testing infrastructure development
```

**Index Completion Session:**
```
Executing Final Phase Development...

Session: FW-SESSION-007.md
Phase 3 Progress: Final integration phase
Current Session Scope: Complete Phase 3 and finalize MVP framework

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ REQUIREMENTS-007: ASYNC-STATE-COORDINATION  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â•â•â• RED PHASE: testMVPAsyncStateCoordination â•â•â•
Writing MVP async coordination test... Done
Running test... Failed (expected)
Time: 3m 22s

â•â•â• GREEN PHASE: MVP Implementation â•â•â•
Implementing minimal viable async coordination... Done
Running test... Passed
Time: 10m 45s

â•â•â• REFACTOR PHASE: MVP Optimization â•â•â•
Optimizing for MVP async patterns... Done
All tests passing âœ“
Time: 7m 15s

âœ“ REQUIREMENTS-007 COMPLETED!
âœ“ PHASE 3 INTEGRATION COMPLETE!

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸš€ MVP FRAMEWORK DEVELOPMENT COMPLETE! ğŸš€    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Phase-Driven Development Complete!
Generated: AxiomFramework/FW-SESSION-007.md
Session Duration: 1.5 hours
Total Development Sessions: 7
Total Requirements Completed: 7/7
Total Development Time: 14.2 hours
Phases: 3/3 Complete âœ“
MVP Framework Ready - Optimized for rapid application development!
```

## Session Artifact Structure

The session file is continuously updated during development with:

### 1. Session Header (Initial)
- **Development Cycle Index**: Link to cycle index being executed
- **Current Phase**: Phase being developed with exit criteria
- **Phase Progress**: Phase completion status and milestone tracking
- **Session Number**: Auto-determined from existing sessions
- **Start Time**: When development began
- **MVP Focus**: Phase objectives and critical path requirements

### 2. MVP TDD Development Log (Updated per cycle)
Each REDâ†’GREENâ†’REFACTOR cycle is documented with:
- **MVP Test Code**: 
  - Implementation: Test for essential MVP behavior
  - Refactoring: Test for critical behavior preservation
- **MVP Development Work**: 
  - Implementation: Minimal viable code to enable MVP functionality
  - Refactoring: Aggressive simplification with breaking changes for MVP clarity
- **MVP Optimization**: Performance and clarity improvements
- **Development Velocity Insights**: Patterns that accelerate MVP development
- **MVP Metrics**: Duration, code reduction, developer experience improvements

### 3. API Design Decisions (As they occur)
- **Decision Point**: When design choice needed
- **Options Considered**: Alternatives evaluated
- **Choice Made**: Final decision with rationale
- **Pain Point Link**: How it addresses original issue

### 4. Validation Results (Continuous)
- **Test Results**: Pass/fail status updates
- **Performance Metrics**: Benchmarks as measured
- **Compatibility**: Existing test status
- **Integration**: Real usage validation

### 5. MVP Session Metrics (Final)
- **Total Duration**: Complete session time
- **Phase Progress**: Phase advancement and milestone completion
- **Requirements Status**: 
  - Requirements completed this session
  - Phase completion status
  - Critical path advancement
- **TDD Cycles Completed**: Number of rapid cycles across phase requirements
- **MVP Code Metrics**:
  - Implementation: Essential features delivered for MVP
  - Refactoring: Complexity reduced, development velocity improved
- **Development Velocity**: Time to implement MVP features, developer experience improvements

## Continuous Documentation

The protocol updates the session file at key points:

### During RED Phase
```swift
// Session file updated with:
### RED Phase - testAutomaticStatePersistence
**Test Intent**: Validate automatic state persistence works
```swift
func testAutomaticStatePersistence() async throws {
    // Test implementation
}
```
**Insight**: Need persistence protocol for flexibility
```

### During GREEN Phase
```swift
// Session file updated with:
### GREEN Phase - testAutomaticStatePersistence
**Approach**: Implement minimal PersistenceManager
```swift
// Implementation code
```
**MVP Optimization**: Simplified for maximum development velocity
```

### During REFACTOR Phase
```swift
// Session file updated with:
### REFACTOR Phase - testAutomaticStatePersistence
**Optimization Focus**: Extract reusable provider pattern
```swift
// Refactored code
```
**Pattern Emerged**: Provider pattern for storage abstraction
```

## TDD Execution Workflow

The protocol executes development through strict TDD phases:

### 1. Test-First Implementation
For each pain point from requirements:
- Write failing test that validates resolution
- Run test to confirm it fails correctly
- Implement minimal code to pass
- Refactor while keeping tests green

### 2. Continuous Validation
After each code change:
- Run all tests to ensure no regression
- Measure performance against targets
- Verify MVP simplicity and clarity maintained
- Update session file with results

### 3. Session File Updates
The protocol updates the session file:
- After each phase completion
- When insights are discovered
- At design decision points
- With final metrics and outcomes

### 4. Final Artifact Generation
Upon completion:
- Session file saved in framework directory
- All TDD cycles documented
- Metrics and validations recorded
- Ready for analysis protocol

## Issue Resolution Verification

The protocol ensures each issue is truly resolved through active fixing:

### Requirements Traceability (Fix Verification)
- **Implementation**: Every test links to specific pain point that gets fixed
- **Refactoring**: Every test ensures fixes preserve essential behavior while transforming code
- Metrics prove problems are fixed, not just marked or avoided
- **Implementation**: Original scenario now works smoothly through fixes
- **Refactoring**: Problems are fixed through dramatic simplification, code is transformed not deprecated
- **No Deprecation**: Every identified issue results in a fix, never just a deprecation notice

### Continuous Testing
- Tests run after every change
- Performance benchmarked throughout
- Integration verified with examples
- No new friction introduced

### Documentation Quality
- Session captures complete journey (implementation or refactoring)
- Decisions explained with context
- Patterns identified for reuse
- Insights valuable for future work
- **Refactoring**: Before/after comparisons with measurable improvements

## Best Practices

1. **Multi-Requirement Session Management**
   - Parse requirements index to understand overall scope
   - Check existing sessions to determine progress
   - Plan session scope based on priorities and dependencies
   - Number sessions sequentially across all requirements
   - Save session file after each requirement completion
   - Update index progress after each session

2. **TDD Execution Discipline**
   - **RED**: Test must fail for the right reason
   - **GREEN**: Write only enough code to pass
   - **REFACTOR**: Improve without breaking tests
   - Never skip phases or write code without tests

3. **Continuous Documentation**
   - Update session file immediately after insights
   - Include actual code snippets, not placeholders
   - Document why decisions were made
   - Track exact timings for each phase

4. **Issue Validation**
   - **Implementation**: Test with exact scenarios from requirements
   - **Refactoring**: Verify behavior preservation while improving code
   - Measure actual improvement metrics
   - **Implementation**: Verify original workarounds eliminated
   - **Refactoring**: Confirm problems fixed through transformation and aggressive simplification
   - Confirm no new issues introduced

5. **MVP Framework Evolution Through Fixing**
   - Fix existing patterns by creating better MVP-optimized versions
   - Fix complexity through breaking changes that simplify
   - Run full test suite frequently to verify fixes
   - Fix friction points to optimize development velocity
   - Transform problematic APIs into clean solutions, never deprecate

6. **Session Completion**
   - **Per Requirement**: Verify all pain points/issues addressed
   - **Session Level**: Update requirements index with progress
   - Run final performance benchmarks
   - Update session with complete metrics and next session plan
   - Save in framework's session directory
   - **Overall**: Track completion toward index goals

## Session Storage

Generated sessions are stored in the framework directory:
```
AxiomFramework/
â”œâ”€â”€ requirements-index.md  (master requirements list)
â”œâ”€â”€ REQUIREMENTS-001-PERSISTENCE-CAPABILITY.md (IMPLEMENTATION)
â”œâ”€â”€ REQUIREMENTS-002-STATE-DEDUPLICATION.md (REFACTORING)
â”œâ”€â”€ REQUIREMENTS-003-ASYNC-CAPABILITIES.md (IMPLEMENTATION)
â”œâ”€â”€ REQUIREMENTS-004-ERROR-HANDLING.md (IMPLEMENTATION)
â”œâ”€â”€ [...additional requirements...]
â”œâ”€â”€ FW-SESSION-001.md  (multi-requirement session 1)
â”œâ”€â”€ FW-SESSION-002.md  (multi-requirement session 2)
â”œâ”€â”€ FW-SESSION-003.md  (multi-requirement session 3)
â”œâ”€â”€ [...additional sessions...]
â””â”€â”€ FW-SESSION-012.md  (final completion session)
```

This enables tracking of overall progress across all requirements and provides a complete development history from initial requirements through final implementation.

## Index Progress Management

The protocol automatically updates the requirements index as work progresses:

### Phase Progress Tracking
- **PENDING**: Phase not yet started, dependencies not satisfied
- **IN-PROGRESS**: Phase partially completed, active development
- **COMPLETED**: Phase fully implemented with exit criteria met
- **READY**: Phase dependencies satisfied, ready for development

### Automatic Updates
After each session, the protocol updates:
```markdown
**Phase 1**: COMPLETED âœ“
**Phase 2**: COMPLETED âœ“
**Phase 3**: IN-PROGRESS

### Phase 1: Foundation
**Status**: COMPLETED âœ“
**Sessions**: FW-SESSION-001, FW-SESSION-002, FW-SESSION-003
**Completion Date**: 2024-01-15
**MVP Impact**: Core state management ready for application development

### Phase 3: Integration  
**Status**: IN-PROGRESS (1/3 requirements complete)
**Current Session**: FW-SESSION-007
**Next Steps**: Complete async state coordination for MVP readiness
**Critical Path**: Blocking final MVP framework release
```

### Session Planning Updates
The protocol automatically plans next sessions:
```markdown
## Next Session Plan (FW-SESSION-008)
**Priority**: Begin Phase 3 final integration requirements
**MVP Milestone**: Complete framework for application development
**Estimated Duration**: 2-3 hours
**Critical Path**: Final MVP framework delivery
**Dependencies**: Phase 2 completed (testing infrastructure ready)
```

## Error Handling and Resumption

### Development Interruptions
If phase development is interrupted:
- Session file preserves progress on current phase requirements
- Cycle index maintains phase-level progress tracking
- Phases marked as IN-PROGRESS can be resumed at requirement level
- Next execution detects incomplete phase and continues appropriately
- MVP development momentum preserved through comprehensive documentation

### Test Failures (Unexpected)
When tests fail unexpectedly:
- Document the failure in session
- Analyze why the failure occurred
- Simplify approach aggressively, breaking changes welcomed
- Continue with MVP-optimized implementation

### Session Recovery
The phase-driven protocol can recover from:
- Build failures (fix and continue with current phase)
- Test timeouts (adjust MVP scope and retry, aggressive simplification)
- Design pivots (document rationale and update phase requirements)
- Performance issues (profile and optimize for MVP, breaking changes acceptable for simplicity)
- Dependency issues (reorder within phase or escalate to phase dependencies)

All challenges become part of the MVP development learning record and inform rapid iteration strategies.

## Fix Don't Deprecate Summary

This protocol enforces a strict "Fix Don't Deprecate" policy throughout all development:
- Every problem identified gets actively fixed, not marked as deprecated
- Breaking changes are used to fix issues properly, not to deprecate functionality
- Code transformation replaces problematic implementations with better solutions
- Session documentation tracks fixes made, not deprecations added
- The framework continuously improves through fixing, never accumulates deprecation warnings
- MVP development benefits from clean, fixed code rather than deprecated APIs with warnings

The result: A framework that gets progressively better through active problem-solving, not one that accumulates technical debt through deprecation.