using System.Reflection;

namespace AxiomEndpoints.Aspire.PackageGeneration.CodeGeneration;

/// <summary>
/// Interface for language-specific code generators
/// </summary>
public interface ICodeGenerator
{
    /// <summary>
    /// Target language for this generator
    /// </summary>
    PackageLanguage Language { get; }

    /// <summary>
    /// Generate code for the specified assembly and configuration
    /// </summary>
    Task<CodeGenerationResult> GenerateAsync(
        Assembly assembly,
        LanguagePackageConfig config,
        CodeQualityConfig qualityConfig,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Validate that this generator can handle the given configuration
    /// </summary>
    Task<bool> CanGenerateAsync(LanguagePackageConfig config, CancellationToken cancellationToken = default);
}

/// <summary>
/// Result of code generation
/// </summary>
public class CodeGenerationResult
{
    public bool Success { get; set; }
    public string? Error { get; set; }
    public List<GeneratedFile> GeneratedFiles { get; set; } = new();
    public List<string> Warnings { get; set; } = new();
    public CodeGenerationMetrics Metrics { get; set; } = new();
}

/// <summary>
/// Generated file information
/// </summary>
public class GeneratedFile
{
    public required string RelativePath { get; set; }
    public required string Content { get; set; }
    public string ContentType { get; set; } = "text/plain";
    public bool IsBinary { get; set; } = false;
    public Dictionary<string, string> Metadata { get; set; } = new();
}

/// <summary>
/// Code generation metrics
/// </summary>
public class CodeGenerationMetrics
{
    public int LinesOfCode { get; set; }
    public int NumberOfFiles { get; set; }
    public int NumberOfTypes { get; set; }
    public int NumberOfMethods { get; set; }
    public TimeSpan GenerationTime { get; set; }
    public long TotalSizeBytes { get; set; }
}

/// <summary>
/// Base implementation for code generators
/// </summary>
public abstract class BaseCodeGenerator : ICodeGenerator
{
    public abstract PackageLanguage Language { get; }

    public virtual Task<bool> CanGenerateAsync(LanguagePackageConfig config, CancellationToken cancellationToken = default)
    {
        // Basic validation - can be overridden by specific generators
        return Task.FromResult(!string.IsNullOrWhiteSpace(config.PackageName) && 
                              !string.IsNullOrWhiteSpace(config.OutputPath));
    }

    public abstract Task<CodeGenerationResult> GenerateAsync(
        Assembly assembly,
        LanguagePackageConfig config,
        CodeQualityConfig qualityConfig,
        CancellationToken cancellationToken = default);

    public static string GenerateFileHeader(string fileName, CodeQualityConfig qualityConfig)
    {
        if (!qualityConfig.Documentation.GenerateInlineComments)
            return string.Empty;

        return $"""
            // 
            // {fileName}
            // Generated by Axiom Endpoints Package Generator
            // 
            // Generated on: {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC
            // Generator Version: 1.0.0
            // 
            // This file was automatically generated. Do not modify directly.
            // 
            
            """;
    }

    public static string GenerateDocComment(string description, PackageLanguage language, bool includeExample = false)
    {
        return language switch
        {
            PackageLanguage.Swift => GenerateSwiftDocComment(description, includeExample),
            PackageLanguage.Kotlin => GenerateKotlinDocComment(description, includeExample),
            PackageLanguage.CSharp => GenerateCSharpDocComment(description, includeExample),
            _ => $"// {description}"
        };
    }

    private static string GenerateSwiftDocComment(string description, bool includeExample)
    {
        var doc = $"/// {description}";
        if (includeExample)
        {
            doc += "\n/// \n/// # Example\n/// ```swift\n/// // Usage example here\n/// ```";
        }
        return doc;
    }

    private static string GenerateKotlinDocComment(string description, bool includeExample)
    {
        var doc = $"/**\n * {description}";
        if (includeExample)
        {
            doc += "\n *\n * ## Example\n * ```kotlin\n * // Usage example here\n * ```";
        }
        doc += "\n */";
        return doc;
    }

    private static string GenerateCSharpDocComment(string description, bool includeExample)
    {
        var doc = $"/// <summary>\n/// {description}\n/// </summary>";
        if (includeExample)
        {
            doc += "\n/// <example>\n/// <code>\n/// // Usage example here\n/// </code>\n/// </example>";
        }
        return doc;
    }

    protected static string FormatCode(string code, CodeStyleConfig style)
    {
        if (style.IndentationStyle == IndentationStyle.Tabs)
        {
            code = code.Replace(new string(' ', style.IndentSize), "\t");
        }

        var lines = code.Split('\n');
        if (style.LineEndingStyle == LineEndingStyle.Windows)
        {
            return string.Join("\r\n", lines);
        }
        else if (style.LineEndingStyle == LineEndingStyle.Mac)
        {
            return string.Join("\r", lines);
        }

        return code; // Unix line endings (default)
    }
}