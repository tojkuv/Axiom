using System.Text;
using AxiomEndpoints.ProtoGen.Core;

namespace AxiomEndpoints.ProtoGen.Writers;

/// <summary>
/// Writes proto packages to .proto files
/// </summary>
public class ProtoFileWriter
{
    private readonly ProtoWriterOptions _options;

    public ProtoFileWriter(ProtoWriterOptions options)
    {
        _options = options;
    }

    public async Task WritePackageAsync(ProtoPackage package, string outputPath)
    {
        // Create directory structure
        var baseDir = Path.Combine(outputPath, package.Name);
        Directory.CreateDirectory(baseDir);

        // Write main proto file
        var mainProtoPath = Path.Combine(baseDir, $"{package.Name}.proto");
        await WriteProtoFileAsync(mainProtoPath, package);

        // Write separate files for large messages if needed
        if (_options.SplitLargeFiles && package.Messages.Count > _options.MessagesPerFile)
        {
            await WriteSplitFilesAsync(package, baseDir);
        }

        // Write service proto files
        foreach (var service in package.Services)
        {
            var serviceProtoPath = Path.Combine(baseDir, $"{ToSnakeCase(service.Name)}_service.proto");
            await WriteServiceProtoAsync(serviceProtoPath, service, package);
        }

        // Write custom options file
        await WriteCustomOptionsAsync(Path.Combine(baseDir, "axiom_options.proto"));

        // Write build configuration files
        await WriteBuildConfigsAsync(package, baseDir);
    }

    private async Task WriteProtoFileAsync(string path, ProtoPackage package)
    {
        using var writer = new StreamWriter(path);

        // Header
        await writer.WriteLineAsync("// Generated by Axiom Endpoints");
        await writer.WriteLineAsync($"// Version: {package.Version}");
        await writer.WriteLineAsync($"// Generated at: {DateTime.UtcNow:O}");
        await writer.WriteLineAsync();

        // Syntax
        await writer.WriteLineAsync("syntax = \"proto3\";");
        await writer.WriteLineAsync();

        // Package
        await writer.WriteLineAsync($"package {package.Name};");
        await writer.WriteLineAsync();

        // Options
        if (!string.IsNullOrEmpty(package.Options.JavaPackage))
        {
            await writer.WriteLineAsync($"option java_package = \"{package.Options.JavaPackage}\";");
        }
        if (package.Options.JavaMultipleFiles)
        {
            await writer.WriteLineAsync("option java_multiple_files = true;");
        }
        if (!string.IsNullOrEmpty(package.Options.SwiftPrefix))
        {
            await writer.WriteLineAsync($"option swift_prefix = \"{package.Options.SwiftPrefix}\";");
        }
        if (!string.IsNullOrEmpty(package.Options.ObjcClassPrefix))
        {
            await writer.WriteLineAsync($"option objc_class_prefix = \"{package.Options.ObjcClassPrefix}\";");
        }
        if (!string.IsNullOrEmpty(package.Options.GoPackage))
        {
            await writer.WriteLineAsync($"option go_package = \"{package.Options.GoPackage}\";");
        }
        await writer.WriteLineAsync($"option csharp_namespace = \"{package.CSharpNamespace}.Grpc\";");
        await writer.WriteLineAsync();

        // Imports
        foreach (var import in package.Imports.Distinct().OrderBy(i => i))
        {
            await writer.WriteLineAsync($"import \"{import}\";");
        }

        if (package.Imports.Any())
        {
            await writer.WriteLineAsync();
        }

        // Enums
        foreach (var protoEnum in package.Enums)
        {
            await WriteEnumAsync(writer, protoEnum);
            await writer.WriteLineAsync();
        }

        // Messages
        foreach (var message in package.Messages)
        {
            await WriteMessageAsync(writer, message);
            await writer.WriteLineAsync();
        }
    }

    private async Task WriteMessageAsync(StreamWriter writer, ProtoMessage message)
    {
        // Documentation
        if (!string.IsNullOrEmpty(message.Documentation))
        {
            await WriteDocumentationAsync(writer, message.Documentation);
        }

        // Message definition
        await writer.WriteLineAsync($"message {message.Name} {{");

        // Options
        foreach (var option in message.Options)
        {
            await writer.WriteLineAsync($"  option {option};");
        }

        if (message.Options.Any())
        {
            await writer.WriteLineAsync();
        }

        // Fields
        foreach (var field in message.Fields)
        {
            // Field documentation
            if (!string.IsNullOrEmpty(field.Documentation))
            {
                await WriteDocumentationAsync(writer, field.Documentation, indent: "  ");
            }

            // Field definition
            var fieldDef = field.IsRepeated && !field.IsMap ? "repeated " : "";
            fieldDef += $"{field.ProtoType} {field.Name} = {field.FieldNumber}";

            // Field options
            if (field.Options.Any())
            {
                fieldDef += " [" + string.Join(", ", field.Options) + "]";
            }

            await writer.WriteLineAsync($"  {fieldDef};");
        }

        // Nested types
        if (message.NestedTypes.Any())
        {
            await writer.WriteLineAsync();
            foreach (var nested in message.NestedTypes)
            {
                await WriteNestedMessageAsync(writer, nested, indent: "  ");
            }
        }

        await writer.WriteLineAsync("}");
    }

    private async Task WriteEnumAsync(StreamWriter writer, ProtoEnum protoEnum)
    {
        // Documentation
        if (!string.IsNullOrEmpty(protoEnum.Documentation))
        {
            await WriteDocumentationAsync(writer, protoEnum.Documentation);
        }

        // Enum definition
        await writer.WriteLineAsync($"enum {protoEnum.Name} {{");

        // Options
        foreach (var option in protoEnum.Options)
        {
            await writer.WriteLineAsync($"  option {option};");
        }

        if (protoEnum.Options.Any())
        {
            await writer.WriteLineAsync();
        }

        // Values
        foreach (var value in protoEnum.Values)
        {
            // Value documentation
            if (!string.IsNullOrEmpty(value.Documentation))
            {
                await WriteDocumentationAsync(writer, value.Documentation, indent: "  ");
            }

            // Value definition
            var valueDef = $"{value.Name} = {value.Value}";

            // Value options
            if (value.Options.Any())
            {
                valueDef += " [" + string.Join(", ", value.Options) + "]";
            }

            await writer.WriteLineAsync($"  {valueDef};");
        }

        await writer.WriteLineAsync("}");
    }

    private async Task WriteServiceProtoAsync(string path, ProtoService service, ProtoPackage package)
    {
        using var writer = new StreamWriter(path);

        // Header
        await writer.WriteLineAsync("// Generated by Axiom Endpoints");
        await writer.WriteLineAsync($"// Service: {service.Name}");
        await writer.WriteLineAsync($"// Generated at: {DateTime.UtcNow:O}");
        await writer.WriteLineAsync();

        // Syntax
        await writer.WriteLineAsync("syntax = \"proto3\";");
        await writer.WriteLineAsync();

        // Package
        await writer.WriteLineAsync($"package {package.Name};");
        await writer.WriteLineAsync();

        // Import main proto file
        await writer.WriteLineAsync($"import \"{package.Name}.proto\";");
        await writer.WriteLineAsync();

        // Service definition
        if (!string.IsNullOrEmpty(service.Documentation))
        {
            await WriteDocumentationAsync(writer, service.Documentation);
        }

        await writer.WriteLineAsync($"service {service.Name} {{");

        // Options
        foreach (var option in service.Options)
        {
            await writer.WriteLineAsync($"  option {option};");
        }

        if (service.Options.Any())
        {
            await writer.WriteLineAsync();
        }

        // RPCs
        foreach (var rpc in service.Rpcs)
        {
            // RPC documentation
            if (!string.IsNullOrEmpty(rpc.Documentation))
            {
                await WriteDocumentationAsync(writer, rpc.Documentation, indent: "  ");
            }

            // RPC definition
            var requestStream = rpc.IsClientStreaming ? "stream " : "";
            var responseStream = rpc.IsServerStreaming ? "stream " : "";
            var rpcDef = $"rpc {rpc.Name}({requestStream}{rpc.RequestType}) returns ({responseStream}{rpc.ResponseType})";

            // RPC options
            if (rpc.Options.Any())
            {
                await writer.WriteLineAsync($"  {rpcDef} {{");
                foreach (var option in rpc.Options)
                {
                    await writer.WriteLineAsync($"    option {option};");
                }
                await writer.WriteLineAsync("  }");
            }
            else
            {
                await writer.WriteLineAsync($"  {rpcDef};");
            }
        }

        await writer.WriteLineAsync("}");
    }

    private async Task WriteCustomOptionsAsync(string path)
    {
        using var writer = new StreamWriter(path);

        await writer.WriteLineAsync("// Custom options for Axiom types");
        await writer.WriteLineAsync();
        await writer.WriteLineAsync("syntax = \"proto3\";");
        await writer.WriteLineAsync();
        await writer.WriteLineAsync("package axiom;");
        await writer.WriteLineAsync();
        await writer.WriteLineAsync("import \"google/protobuf/descriptor.proto\";");
        await writer.WriteLineAsync();

        // Field options
        await writer.WriteLineAsync("extend google.protobuf.FieldOptions {");
        await writer.WriteLineAsync("  bool required = 50001;");
        await writer.WriteLineAsync("  int32 min_length = 50002;");
        await writer.WriteLineAsync("  int32 max_length = 50003;");
        await writer.WriteLineAsync("  string pattern = 50004;");
        await writer.WriteLineAsync("  string min_value = 50005;");
        await writer.WriteLineAsync("  string max_value = 50006;");
        await writer.WriteLineAsync("}");
        await writer.WriteLineAsync();

        // Message options
        await writer.WriteLineAsync("extend google.protobuf.MessageOptions {");
        await writer.WriteLineAsync("  bool domain_event = 50101;");
        await writer.WriteLineAsync("  bool timestamp = 50102;");
        await writer.WriteLineAsync("  string aggregate = 50103;");
        await writer.WriteLineAsync("}");
        await writer.WriteLineAsync();

        // Custom decimal type
        await writer.WriteLineAsync("// Decimal type for financial calculations");
        await writer.WriteLineAsync("message Decimal {");
        await writer.WriteLineAsync("  // The whole units of the amount");
        await writer.WriteLineAsync("  int64 units = 1;");
        await writer.WriteLineAsync("  // Number of nano (10^-9) units of the amount");
        await writer.WriteLineAsync("  int32 nanos = 2;");
        await writer.WriteLineAsync("}");
    }

    private async Task WriteSplitFilesAsync(ProtoPackage package, string baseDir)
    {
        var messageChunks = package.Messages
            .Select((message, index) => new { message, index })
            .GroupBy(x => x.index / _options.MessagesPerFile)
            .ToList();

        for (int i = 0; i < messageChunks.Count; i++)
        {
            var chunk = messageChunks[i];
            var chunkPath = Path.Combine(baseDir, $"{package.Name}_types_{i + 1}.proto");
            
            using var writer = new StreamWriter(chunkPath);
            
            // Header
            await writer.WriteLineAsync("// Generated by Axiom Endpoints");
            await writer.WriteLineAsync($"// Types chunk {i + 1}");
            await writer.WriteLineAsync($"// Generated at: {DateTime.UtcNow:O}");
            await writer.WriteLineAsync();

            // Syntax and package
            await writer.WriteLineAsync("syntax = \"proto3\";");
            await writer.WriteLineAsync();
            await writer.WriteLineAsync($"package {package.Name};");
            await writer.WriteLineAsync();

            // Messages
            foreach (var item in chunk)
            {
                await WriteMessageAsync(writer, item.message);
                await writer.WriteLineAsync();
            }
        }
    }

    private async Task WriteBuildConfigsAsync(ProtoPackage package, string baseDir)
    {
        // Write buf.yaml for buf tool
        var bufYaml = $@"version: v1
build:
  roots:
    - .
breaking:
  use:
    - FILE
lint:
  use:
    - DEFAULT
";

        await File.WriteAllTextAsync(Path.Combine(baseDir, "buf.yaml"), bufYaml);

        // Write buf.gen.yaml for code generation
        var bufGenYaml = $@"version: v1
plugins:
  - plugin: buf.build/protocolbuffers/csharp:v3.25.2
    out: gen/csharp
    opt: file_extension=.g.cs
  - plugin: buf.build/grpc/csharp:v2.60.0
    out: gen/csharp
    opt: no_server=true
";

        await File.WriteAllTextAsync(Path.Combine(baseDir, "buf.gen.yaml"), bufGenYaml);
    }

    private async Task WriteDocumentationAsync(StreamWriter writer, string documentation, string indent = "")
    {
        var lines = documentation.Split('\n', StringSplitOptions.RemoveEmptyEntries);
        
        foreach (var line in lines)
        {
            await writer.WriteLineAsync($"{indent}// {line.Trim()}");
        }
    }

    private async Task WriteNestedMessageAsync(StreamWriter writer, ProtoMessage message, string indent)
    {
        if (!string.IsNullOrEmpty(message.Documentation))
        {
            await WriteDocumentationAsync(writer, message.Documentation, indent);
        }

        await writer.WriteLineAsync($"{indent}message {message.Name} {{");

        foreach (var field in message.Fields)
        {
            if (!string.IsNullOrEmpty(field.Documentation))
            {
                await WriteDocumentationAsync(writer, field.Documentation, indent + "  ");
            }

            var fieldDef = field.IsRepeated && !field.IsMap ? "repeated " : "";
            fieldDef += $"{field.ProtoType} {field.Name} = {field.FieldNumber}";

            if (field.Options.Any())
            {
                fieldDef += " [" + string.Join(", ", field.Options) + "]";
            }

            await writer.WriteLineAsync($"{indent}  {fieldDef};");
        }

        await writer.WriteLineAsync($"{indent}}}");
    }

    private string ToSnakeCase(string input)
    {
        if (string.IsNullOrEmpty(input))
            return input;

        var result = new StringBuilder();
        
        for (int i = 0; i < input.Length; i++)
        {
            if (i > 0 && char.IsUpper(input[i]))
            {
                result.Append('_');
            }
            result.Append(char.ToLowerInvariant(input[i]));
        }

        return result.ToString();
    }
}

public class ProtoWriterOptions
{
    public bool SplitLargeFiles { get; set; } = false;
    public int MessagesPerFile { get; set; } = 50;
    public bool IncludeDocumentation { get; set; } = true;
    public bool GenerateBufConfigs { get; set; } = true;
}