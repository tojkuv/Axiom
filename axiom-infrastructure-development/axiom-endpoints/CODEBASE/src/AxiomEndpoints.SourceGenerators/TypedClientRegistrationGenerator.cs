using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;

namespace AxiomEndpoints.SourceGenerators;

internal static class TypedClientRegistrationGenerator
{
    public static string GenerateClientRegistration(
        ImmutableArray<EndpointInfo> endpoints,
        CompilationInfo compilation)
    {
        // Only generate registration if there are concrete endpoints
        var concreteEndpoints = endpoints.Where(e => e.Kind == EndpointKind.Unary && 
                                                    !string.IsNullOrEmpty(e.RequestType) && 
                                                    !string.IsNullOrEmpty(e.ResponseType) &&
                                                    !e.RequestType.Contains("TRequest") &&
                                                    !e.ResponseType.Contains("TResponse")).ToArray();
        
        if (concreteEndpoints.Length == 0)
            return string.Empty;

        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using Microsoft.Extensions.Logging;");
        sb.AppendLine();
        sb.AppendLine($"namespace {compilation.RootNamespace}.Generated.Clients;");
        sb.AppendLine();

        // Generate service registration extensions
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Extension methods for registering typed Axiom clients");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[System.CodeDom.Compiler.GeneratedCode(\"AxiomEndpoints.SourceGenerators\", \"1.0.0\")]");
        sb.AppendLine("public static class AxiomClientRegistrationExtensions");
        sb.AppendLine("{");

        // Generate AddAxiomClients method
        GenerateAddAxiomClientsMethod(sb, concreteEndpoints, compilation);

        // Generate individual service client registration methods
        var serviceGroups = concreteEndpoints
            .GroupBy(e => ExtractServiceName(e.Namespace))
            .ToArray();

        foreach (var serviceGroup in serviceGroups)
        {
            GenerateServiceClientRegistration(sb, serviceGroup.Key, serviceGroup.ToArray());
        }

        sb.AppendLine("}");
        sb.AppendLine();

        // Generate typed HTTP client factory
        GenerateTypedHttpClientFactory(sb, serviceGroups, compilation);

        return sb.ToString();
    }

    private static void GenerateAddAxiomClientsMethod(StringBuilder sb, EndpointInfo[] endpoints, CompilationInfo compilation)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Register all Axiom typed clients with dependency injection");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static IServiceCollection AddAxiomClients(");
        sb.AppendLine("        this IServiceCollection services,");
        sb.AppendLine("        Action<AxiomClientOptions>? configure = null)");
        sb.AppendLine("    {");
        sb.AppendLine("        var options = new AxiomClientOptions();");
        sb.AppendLine("        configure?.Invoke(options);");
        sb.AppendLine();

        // Register main client for backward compatibility
        sb.AppendLine("        // Register main AxiomClient for backward compatibility");
        sb.AppendLine("        services.AddHttpClient<AxiomClient>(client =>");
        sb.AppendLine("        {");
        sb.AppendLine("            if (!string.IsNullOrEmpty(options.BaseAddress))");
        sb.AppendLine("                client.BaseAddress = new Uri(options.BaseAddress);");
        sb.AppendLine("            client.Timeout = options.Timeout;");
        sb.AppendLine("        });");
        sb.AppendLine();

        // Register service-specific clients
        var serviceGroups = endpoints
            .GroupBy(e => ExtractServiceName(e.Namespace))
            .ToArray();

        foreach (var serviceGroup in serviceGroups)
        {
            var serviceName = serviceGroup.Key;
            var clientName = $"{serviceName}Client";
            
            sb.AppendLine($"        // Register {serviceName} service client");
            sb.AppendLine($"        services.Add{serviceName}Client(options.{serviceName}BaseAddress ?? options.BaseAddress);");
        }

        sb.AppendLine();
        sb.AppendLine("        return services;");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void GenerateServiceClientRegistration(StringBuilder sb, string serviceName, EndpointInfo[] endpoints)
    {
        var clientName = $"{serviceName}Client";
        
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Register {serviceName} typed client with dependency injection");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    public static IServiceCollection Add{serviceName}Client(");
        sb.AppendLine("        this IServiceCollection services,");
        sb.AppendLine("        string? baseAddress = null)");
        sb.AppendLine("    {");
        sb.AppendLine($"        services.AddHttpClient<I{clientName}, {clientName}>(client =>");
        sb.AppendLine("        {");
        sb.AppendLine("            if (!string.IsNullOrEmpty(baseAddress))");
        sb.AppendLine("                client.BaseAddress = new Uri(baseAddress);");
        sb.AppendLine("        });");
        sb.AppendLine();
        sb.AppendLine($"        return services;");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Service discovery integration commented out - add reference to AxiomEndpoints.Aspire to enable
        // sb.AppendLine($"    /// <summary>");
        // sb.AppendLine($"    /// Register {serviceName} typed client with service discovery");
        // sb.AppendLine($"    /// </summary>");
        // sb.AppendLine($"    public static IServiceCollection Add{serviceName}ClientWithServiceDiscovery(");
        // sb.AppendLine("        this IServiceCollection services,");
        // sb.AppendLine($"        string serviceName = \"{serviceName.ToLowerInvariant()}\")");
        // sb.AppendLine("    {");
        // sb.AppendLine($"        services.AddHttpClient<I{clientName}, {clientName}>((provider, client) =>");
        // sb.AppendLine("        {");
        // sb.AppendLine("            var serviceDiscovery = provider.GetRequiredService<IAxiomServiceDiscovery>();");
        // sb.AppendLine("            var baseUri = serviceDiscovery.ResolveServiceAsync(serviceName).GetAwaiter().GetResult();");
        // sb.AppendLine("            if (baseUri != null)");
        // sb.AppendLine("                client.BaseAddress = baseUri;");
        // sb.AppendLine("        });");
        // sb.AppendLine();
        // sb.AppendLine($"        return services;");
        // sb.AppendLine("    }");
        // sb.AppendLine();
    }

    private static void GenerateTypedHttpClientFactory(StringBuilder sb, IGrouping<string, EndpointInfo>[] serviceGroups, CompilationInfo compilation)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Configuration options for Axiom clients");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[System.CodeDom.Compiler.GeneratedCode(\"AxiomEndpoints.SourceGenerators\", \"1.0.0\")]");
        sb.AppendLine("public class AxiomClientOptions");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Default base address for all clients");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public string? BaseAddress { get; set; }");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Default timeout for all HTTP requests");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public TimeSpan Timeout { get; set; } = TimeSpan.FromSeconds(30);");
        sb.AppendLine();

        // Generate service-specific base address properties
        foreach (var serviceGroup in serviceGroups)
        {
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// Base address for {serviceGroup.Key} service (overrides BaseAddress if set)");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    public string? {serviceGroup.Key}BaseAddress {{ get; set; }}");
            sb.AppendLine();
        }

        sb.AppendLine("}");
        sb.AppendLine();

        // Generate factory interface and implementation
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Factory for creating typed Axiom clients");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[System.CodeDom.Compiler.GeneratedCode(\"AxiomEndpoints.SourceGenerators\", \"1.0.0\")]");
        sb.AppendLine("public interface IAxiomClientFactory");
        sb.AppendLine("{");

        foreach (var serviceGroup in serviceGroups)
        {
            var clientName = $"{serviceGroup.Key}Client";
            sb.AppendLine($"    I{clientName} Create{clientName}();");
        }

        sb.AppendLine("}");
        sb.AppendLine();

        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Default implementation of IAxiomClientFactory");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[System.CodeDom.Compiler.GeneratedCode(\"AxiomEndpoints.SourceGenerators\", \"1.0.0\")]");
        sb.AppendLine("internal class AxiomClientFactory : IAxiomClientFactory");
        sb.AppendLine("{");
        sb.AppendLine("    private readonly IServiceProvider _serviceProvider;");
        sb.AppendLine();
        sb.AppendLine("    public AxiomClientFactory(IServiceProvider serviceProvider)");
        sb.AppendLine("    {");
        sb.AppendLine("        _serviceProvider = serviceProvider;");
        sb.AppendLine("    }");
        sb.AppendLine();

        foreach (var serviceGroup in serviceGroups)
        {
            var clientName = $"{serviceGroup.Key}Client";
            sb.AppendLine($"    public I{clientName} Create{clientName}()");
            sb.AppendLine("    {");
            sb.AppendLine($"        return _serviceProvider.GetRequiredService<I{clientName}>();");
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        sb.AppendLine("}");
    }

    private static string ExtractServiceName(string namespaceName)
    {
        // Extract service name from namespace like "MyApp.Services.Users" -> "Users"
        var parts = namespaceName.Split('.');
        return parts.Length > 0 ? parts[parts.Length - 1] : "Unknown";
    }
}