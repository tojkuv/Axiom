using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace AxiomEndpoints.SourceGenerators;

internal static class MiddlewarePipelineGenerator
{
    public static string GenerateMiddlewarePipelines(
        ImmutableArray<EndpointWithMiddleware> endpoints,
        CompilationInfo compilation)
    {
        if (endpoints.IsEmpty)
            return string.Empty;

        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using AxiomEndpoints.Core.Middleware;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using System.Collections.Frozen;");
        sb.AppendLine();
        sb.AppendLine($"namespace {compilation.RootNamespace}.Generated;");
        sb.AppendLine();
        sb.AppendLine("[System.CodeDom.Compiler.GeneratedCode(\"AxiomEndpoints.SourceGenerators\", \"1.0.0\")]");
        sb.AppendLine("internal static class MiddlewarePipelines");
        sb.AppendLine("{");

        // Generate factory method
        GenerateFactoryMethod(sb, endpoints);

        // Generate individual pipeline creators
        foreach (var endpoint in endpoints)
        {
            GeneratePipelineCreator(sb, endpoint);
        }

        // Generate default pipeline
        GenerateDefaultPipeline(sb);

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GenerateFactoryMethod(StringBuilder sb, ImmutableArray<EndpointWithMiddleware> endpoints)
    {
        sb.AppendLine("    public static IMiddlewarePipeline<TRequest, TResponse> Create<TEndpoint, TRequest, TResponse>(IServiceProvider services)");
        sb.AppendLine("        where TEndpoint : IAxiom<TRequest, TResponse>");
        sb.AppendLine("    {");
        sb.AppendLine("        return typeof(TEndpoint).Name switch");
        sb.AppendLine("        {");

        foreach (var endpoint in endpoints)
        {
            sb.AppendLine($"            nameof({endpoint.TypeName}) => Create{endpoint.TypeName}Pipeline<TRequest, TResponse>(services),");
        }

        sb.AppendLine("            _ => CreateDefaultPipeline<TRequest, TResponse>(services)");
        sb.AppendLine("        };");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Overload for Type parameter
        sb.AppendLine("    public static IMiddlewarePipeline<TRequest, TResponse> Create<TRequest, TResponse>(Type endpointType, IServiceProvider services)");
        sb.AppendLine("    {");
        sb.AppendLine("        return endpointType.Name switch");
        sb.AppendLine("        {");

        foreach (var endpoint in endpoints)
        {
            sb.AppendLine($"            nameof({endpoint.TypeName}) => Create{endpoint.TypeName}Pipeline<TRequest, TResponse>(services),");
        }

        sb.AppendLine("            _ => CreateDefaultPipeline<TRequest, TResponse>(services)");
        sb.AppendLine("        };");
        sb.AppendLine("    }");
    }

    private static void GeneratePipelineCreator(StringBuilder sb, EndpointWithMiddleware endpoint)
    {
        sb.AppendLine();
        sb.AppendLine($"    private static IMiddlewarePipeline<TRequest, TResponse> Create{endpoint.TypeName}Pipeline<TRequest, TResponse>(IServiceProvider services)");
        sb.AppendLine("    {");

        // Generate filters
        sb.AppendLine("        var filters = new List<IEndpointFilter>");
        sb.AppendLine("        {");

        foreach (var filter in endpoint.Filters.OrderBy(f => f.Order))
        {
            if (filter.RequiresService)
            {
                sb.AppendLine($"            services.GetRequiredService<{filter.TypeName}>(),");
            }
            else
            {
                sb.AppendLine($"            new {filter.TypeName}({GenerateAttributeArgs(filter)}),");
            }
        }

        sb.AppendLine("        };");
        sb.AppendLine();

        // Generate result filters
        sb.AppendLine("        var resultFilters = new List<IEndpointResultFilter>");
        sb.AppendLine("        {");

        foreach (var filter in endpoint.ResultFilters.OrderBy(f => f.Order))
        {
            if (filter.RequiresService)
            {
                sb.AppendLine($"            services.GetRequiredService<{filter.TypeName}>(),");
            }
            else
            {
                sb.AppendLine($"            new {filter.TypeName}({GenerateAttributeArgs(filter)}),");
            }
        }

        sb.AppendLine("        };");
        sb.AppendLine();

        // Generate exception filters
        sb.AppendLine("        var exceptionFilters = new List<IEndpointExceptionFilter>");
        sb.AppendLine("        {");

        foreach (var filter in endpoint.ExceptionFilters.OrderBy(f => f.Order))
        {
            if (filter.RequiresService)
            {
                sb.AppendLine($"            services.GetRequiredService<{filter.TypeName}>(),");
            }
            else
            {
                sb.AppendLine($"            new {filter.TypeName}({GenerateAttributeArgs(filter)}),");
            }
        }

        sb.AppendLine("        };");
        sb.AppendLine();

        sb.AppendLine("        return new MiddlewarePipeline<TRequest, TResponse>(");
        sb.AppendLine("            filters,");
        sb.AppendLine("            resultFilters,");
        sb.AppendLine("            exceptionFilters,");
        sb.AppendLine($"            {GenerateEndpointMetadata(endpoint)});");
        sb.AppendLine("    }");
    }

    private static void GenerateDefaultPipeline(StringBuilder sb)
    {
        sb.AppendLine();
        sb.AppendLine("    private static IMiddlewarePipeline<TRequest, TResponse> CreateDefaultPipeline<TRequest, TResponse>(IServiceProvider services)");
        sb.AppendLine("    {");
        sb.AppendLine("        return new MiddlewarePipeline<TRequest, TResponse>(");
        sb.AppendLine("            Array.Empty<IEndpointFilter>(),");
        sb.AppendLine("            Array.Empty<IEndpointResultFilter>(),");
        sb.AppendLine("            Array.Empty<IEndpointExceptionFilter>(),");
        sb.AppendLine("            new EndpointMetadata");
        sb.AppendLine("            {");
        sb.AppendLine("                EndpointType = typeof(object),");
        sb.AppendLine("                Template = \"/\",");
        sb.AppendLine("                Method = HttpMethod.Get");
        sb.AppendLine("            });");
        sb.AppendLine("    }");
    }

    private static string GenerateAttributeArgs(MiddlewareInfo middleware)
    {
        if (!middleware.Arguments.Any())
            return string.Empty;

        var args = new List<string>();
        foreach (var (key, value) in middleware.Arguments)
        {
            if (value is string stringValue)
            {
                args.Add($"{key} = \"{stringValue}\"");
            }
            else if (value is bool boolValue)
            {
                args.Add($"{key} = {(boolValue ? "true" : "false")}");
            }
            else if (value is int intValue)
            {
                args.Add($"{key} = {intValue}");
            }
            else if (value is double doubleValue)
            {
                args.Add($"{key} = {doubleValue}");
            }
            else
            {
                args.Add($"{key} = {value}");
            }
        }

        return string.Join(", ", args);
    }

    private static string GenerateEndpointMetadata(EndpointWithMiddleware endpoint)
    {
        return $@"new EndpointMetadata
            {{
                EndpointType = typeof({endpoint.TypeName}),
                Template = ""/{endpoint.TypeName.ToLowerInvariant()}"",
                Method = HttpMethod.{endpoint.HttpMethod},
                RequiresAuthorization = {(endpoint.RequiresAuthorization ? "true" : "false")},
                AuthorizationPolicy = {(string.IsNullOrEmpty(endpoint.AuthorizationPolicy) ? "null" : $"\"{endpoint.AuthorizationPolicy}\"")},
                AllowAnonymous = {(endpoint.AllowAnonymous ? "true" : "false")},
                RateLimitPolicy = {(string.IsNullOrEmpty(endpoint.RateLimitPolicy) ? "null" : $"\"{endpoint.RateLimitPolicy}\"")},
                CorsPolicy = {(string.IsNullOrEmpty(endpoint.CorsPolicy) ? "null" : $"\"{endpoint.CorsPolicy}\"")},
                CacheDuration = {endpoint.CacheDuration}
            }}";
    }

    public static EndpointWithMiddleware? GetEndpointWithMiddleware(GeneratorSyntaxContext context)
    {
        var node = (TypeDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(node);

        if (symbol is null || !IsEndpointType(symbol))
            return null;

        var filters = new List<MiddlewareInfo>();
        var resultFilters = new List<MiddlewareInfo>();
        var exceptionFilters = new List<MiddlewareInfo>();

        var requiresAuth = false;
        var authPolicy = "";
        var allowAnonymous = false;
        var rateLimitPolicy = "";
        var corsPolicy = "";
        var cacheDuration = 0;

        // Analyze attributes
        foreach (var attribute in symbol.GetAttributes())
        {
            var attributeName = attribute.AttributeClass?.Name ?? "";
            var attributeFullName = attribute.AttributeClass?.ToDisplayString() ?? "";

            var middleware = AnalyzeMiddlewareAttribute(attribute, attributeName, attributeFullName);
            if (middleware != null)
            {
                // Determine which type of middleware this is based on interfaces
                var attributeType = attribute.AttributeClass;
                if (ImplementsInterface(attributeType, "IEndpointFilter"))
                {
                    filters.Add(middleware);
                }
                else if (ImplementsInterface(attributeType, "IEndpointResultFilter"))
                {
                    resultFilters.Add(middleware);
                }
                else if (ImplementsInterface(attributeType, "IEndpointExceptionFilter"))
                {
                    exceptionFilters.Add(middleware);
                }

                // Extract metadata
                if (attributeName.Contains("Authorize"))
                {
                    requiresAuth = true;
                    authPolicy = ExtractStringArgument(attribute, "Policy") ?? "";
                }
                else if (attributeName.Contains("AllowAnonymous"))
                {
                    allowAnonymous = true;
                }
                else if (attributeName.Contains("RateLimit"))
                {
                    rateLimitPolicy = ExtractStringArgument(attribute, "Policy") ?? "default";
                }
                else if (attributeName.Contains("Cors"))
                {
                    corsPolicy = ExtractStringArgument(attribute, "PolicyName") ?? "";
                }
                else if (attributeName.Contains("Cache"))
                {
                    cacheDuration = ExtractIntArgument(attribute, "DurationSeconds") ?? 0;
                }
            }
        }

        var httpMethod = GetHttpMethod(symbol);

        return new EndpointWithMiddleware
        {
            TypeName = symbol.Name,
            Namespace = symbol.ContainingNamespace.ToDisplayString(),
            Filters = filters.ToImmutableArray(),
            ResultFilters = resultFilters.ToImmutableArray(),
            ExceptionFilters = exceptionFilters.ToImmutableArray(),
            RequiresAuthorization = requiresAuth,
            AuthorizationPolicy = authPolicy,
            AllowAnonymous = allowAnonymous,
            RateLimitPolicy = rateLimitPolicy,
            CorsPolicy = corsPolicy,
            CacheDuration = cacheDuration,
            HttpMethod = httpMethod
        };
    }

    private static MiddlewareInfo? AnalyzeMiddlewareAttribute(AttributeData attribute, string attributeName, string attributeFullName)
    {
        // Skip non-middleware attributes
        if (!IsMiddlewareAttribute(attributeName, attributeFullName))
            return null;

        var arguments = new Dictionary<string, object>();
        var order = 0;

        // Extract constructor arguments
        if (attribute.ConstructorArguments.Length > 0)
        {
            for (int i = 0; i < attribute.ConstructorArguments.Length; i++)
            {
                var arg = attribute.ConstructorArguments[i];
                if (arg.Value != null)
                {
                    arguments[$"arg{i}"] = arg.Value;
                }
            }
        }

        // Extract named arguments
        foreach (var namedArg in attribute.NamedArguments)
        {
            if (namedArg.Key == "Order" && namedArg.Value.Value is int orderValue)
            {
                order = orderValue;
            }
            else if (namedArg.Value.Value != null)
            {
                arguments[namedArg.Key] = namedArg.Value.Value;
            }
        }

        return new MiddlewareInfo
        {
            TypeName = attributeFullName,
            Order = order,
            RequiresService = false, // Attributes don't require services
            Arguments = arguments.ToImmutableDictionary()
        };
    }

    private static bool IsMiddlewareAttribute(string attributeName, string attributeFullName)
    {
        var middlewareAttributes = new[]
        {
            "Authorize", "AllowAnonymous", "Cache", "InvalidateCache", "RateLimit", "RateLimitBy",
            "Validate", "Audit", "Observable", "Metric", "Tracing", "PerformanceMonitor",
            "Compress", "Cors", "FeatureFlag", "SecurityHeaders", "Timeout", "Produces", "Consumes"
        };

        return middlewareAttributes.Any(name => 
            attributeName.Contains(name) || 
            attributeFullName.Contains($".{name}Attribute") ||
            attributeFullName.Contains($".Middleware.{name}"));
    }

    private static bool ImplementsInterface(INamedTypeSymbol? type, string interfaceName)
    {
        if (type == null) return false;

        return type.AllInterfaces.Any(i => i.Name == interfaceName) ||
               type.BaseType?.AllInterfaces.Any(i => i.Name == interfaceName) == true;
    }

    private static string? ExtractStringArgument(AttributeData attribute, string argumentName)
    {
        var namedArg = attribute.NamedArguments.FirstOrDefault(na => na.Key == argumentName);
        return namedArg.Value.Value as string;
    }

    private static int? ExtractIntArgument(AttributeData attribute, string argumentName)
    {
        var namedArg = attribute.NamedArguments.FirstOrDefault(na => na.Key == argumentName);
        return namedArg.Value.Value as int?;
    }

    private static string GetHttpMethod(INamedTypeSymbol symbol)
    {
        // Try to determine HTTP method from interfaces or attributes
        var interfaces = symbol.AllInterfaces;
        
        foreach (var iface in interfaces)
        {
            if (iface.Name.Contains("Axiom") && iface.IsGenericType)
            {
                // Check for static Method property
                var methodProperty = symbol.GetMembers("Method").OfType<IPropertySymbol>().FirstOrDefault();
                if (methodProperty?.IsStatic == true)
                {
                    // This is simplified - in reality you'd need to evaluate the property value
                    return "GET"; // Default
                }
            }
        }

        return "GET"; // Default
    }

    private static bool IsEndpointType(INamedTypeSymbol typeSymbol)
    {
        if (typeSymbol.IsAbstract || typeSymbol.TypeKind != TypeKind.Class)
            return false;
            
        return typeSymbol.AllInterfaces.Any(i =>
            i.IsGenericType &&
            (i.Name == "IAxiom" || i.Name == "IRouteAxiom" ||
             i.Name == "IServerStreamAxiom" || i.Name == "IClientStreamAxiom" ||
             i.Name == "IBidirectionalStreamAxiom"));
    }
}

internal class EndpointWithMiddleware
{
    public string TypeName { get; set; } = "";
    public string Namespace { get; set; } = "";
    public ImmutableArray<MiddlewareInfo> Filters { get; set; } = ImmutableArray<MiddlewareInfo>.Empty;
    public ImmutableArray<MiddlewareInfo> ResultFilters { get; set; } = ImmutableArray<MiddlewareInfo>.Empty;
    public ImmutableArray<MiddlewareInfo> ExceptionFilters { get; set; } = ImmutableArray<MiddlewareInfo>.Empty;
    public bool RequiresAuthorization { get; set; }
    public string AuthorizationPolicy { get; set; } = "";
    public bool AllowAnonymous { get; set; }
    public string RateLimitPolicy { get; set; } = "";
    public string CorsPolicy { get; set; } = "";
    public int CacheDuration { get; set; }
    public string HttpMethod { get; set; } = "GET";
}

internal class MiddlewareInfo
{
    public string TypeName { get; set; } = "";
    public int Order { get; set; }
    public bool RequiresService { get; set; }
    public ImmutableDictionary<string, object> Arguments { get; set; } = ImmutableDictionary<string, object>.Empty;
}

