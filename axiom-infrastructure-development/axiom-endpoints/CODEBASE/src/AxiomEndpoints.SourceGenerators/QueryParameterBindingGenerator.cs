using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;

namespace AxiomEndpoints.SourceGenerators;

internal static class QueryParameterBindingGenerator
{
    public static string GenerateParameterBinding(
        ImmutableArray<MinimalEndpointInfo> endpoints,
        CompilationInfo compilation)
    {
        var endpointsWithQueryParams = endpoints
            .Where(e => e.Parameters.Any(p => p.BindingType == ParameterBindingType.Query))
            .ToArray();

        if (endpointsWithQueryParams.Length == 0)
            return string.Empty;

        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Globalization;");
        sb.AppendLine("using Microsoft.AspNetCore.Http;");
        sb.AppendLine("using Microsoft.Extensions.Primitives;");
        sb.AppendLine("using AxiomEndpoints.Core;");
        sb.AppendLine();
        sb.AppendLine($"namespace {compilation.RootNamespace}.Generated;");
        sb.AppendLine();
        sb.AppendLine("[System.CodeDom.Compiler.GeneratedCode(\"AxiomEndpoints.SourceGenerators\", \"1.0.0\")]");
        sb.AppendLine("public static class QueryParameterBinder");
        sb.AppendLine("{");

        foreach (var endpoint in endpointsWithQueryParams)
        {
            GenerateBindingMethod(sb, endpoint);
        }

        // Generate utility methods
        GenerateUtilityMethods(sb);

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GenerateBindingMethod(StringBuilder sb, MinimalEndpointInfo endpoint)
    {
        var routeType = $"{endpoint.MethodName}_Route";
        var queryParams = endpoint.Parameters.Where(p => p.BindingType == ParameterBindingType.Query).ToArray();

        sb.AppendLine($"    public static {routeType} Bind{endpoint.MethodName}Parameters(HttpContext httpContext)");
        sb.AppendLine("    {");
        sb.AppendLine("        var query = httpContext.Request.Query;");
        sb.AppendLine();

        foreach (var param in queryParams)
        {
            GenerateParameterExtraction(sb, param);
        }

        sb.AppendLine();
        sb.AppendLine($"        return new {routeType}");
        sb.AppendLine("        {");

        foreach (var param in queryParams)
        {
            sb.AppendLine($"            {param.Name} = {param.Name.ToLowerInvariant()},");
        }

        sb.AppendLine("        };");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void GenerateParameterExtraction(StringBuilder sb, MinimalEndpointParameter param)
    {
        var varName = param.Name.ToLowerInvariant();
        var queryKey = param.Name;
        
        // Add validation for required parameters
        var isRequired = !param.HasDefaultValue && !IsNullableType(param.Type);
        
        if (isRequired)
        {
            sb.AppendLine($"        if (!query.ContainsKey(\"{queryKey}\") || string.IsNullOrEmpty(query[\"{queryKey}\"].FirstOrDefault()))");
            sb.AppendLine($"            throw new ArgumentException(\"Required query parameter '{queryKey}' is missing or empty.\");");
            sb.AppendLine();
        }

        if (param.Type == "string")
        {
            if (param.HasDefaultValue)
            {
                sb.AppendLine($"        var {varName} = query[\"{queryKey}\"].FirstOrDefault() ?? {param.DefaultValue};");
            }
            else
            {
                sb.AppendLine($"        var {varName} = query[\"{queryKey}\"].FirstOrDefault() ?? string.Empty;");
            }
        }
        else if (param.Type == "int")
        {
            var defaultValue = param.HasDefaultValue ? param.DefaultValue : "0";
            sb.AppendLine($"        var {varName} = ParseInt32(query[\"{queryKey}\"].FirstOrDefault(), {defaultValue});");
        }
        else if (param.Type == "int?")
        {
            sb.AppendLine($"        var {varName} = ParseNullableInt32(query[\"{queryKey}\"].FirstOrDefault());");
        }
        else if (param.Type == "long")
        {
            var defaultValue = param.HasDefaultValue ? param.DefaultValue : "0L";
            sb.AppendLine($"        var {varName} = ParseInt64(query[\"{queryKey}\"].FirstOrDefault(), {defaultValue});");
        }
        else if (param.Type == "bool")
        {
            var defaultValue = param.HasDefaultValue ? param.DefaultValue : "false";
            sb.AppendLine($"        var {varName} = ParseBoolean(query[\"{queryKey}\"].FirstOrDefault(), {defaultValue});");
        }
        else if (param.Type == "DateTime")
        {
            var defaultValue = param.HasDefaultValue ? param.DefaultValue : "DateTime.MinValue";
            sb.AppendLine($"        var {varName} = ParseDateTime(query[\"{queryKey}\"].FirstOrDefault(), {defaultValue});");
        }
        else if (param.Type == "DateTime?")
        {
            sb.AppendLine($"        var {varName} = ParseNullableDateTime(query[\"{queryKey}\"].FirstOrDefault());");
        }
        else if (param.Type == "Guid")
        {
            var defaultValue = param.HasDefaultValue ? param.DefaultValue : "Guid.Empty";
            sb.AppendLine($"        var {varName} = ParseGuid(query[\"{queryKey}\"].FirstOrDefault(), {defaultValue});");
        }
        else if (param.Type == "decimal")
        {
            var defaultValue = param.HasDefaultValue ? param.DefaultValue : "0m";
            sb.AppendLine($"        var {varName} = ParseDecimal(query[\"{queryKey}\"].FirstOrDefault(), {defaultValue});");
        }
        else if (IsEnumType(param.Type))
        {
            var defaultValue = param.HasDefaultValue ? param.DefaultValue : $"default({param.Type})";
            sb.AppendLine($"        var {varName} = ParseEnum<{param.Type}>(query[\"{queryKey}\"].FirstOrDefault(), {defaultValue});");
        }
        else if (IsCollectionType(param.Type))
        {
            var elementType = ExtractElementType(param.Type);
            sb.AppendLine($"        var {varName} = ParseCollection<{elementType}>(query[\"{queryKey}\"]);");
        }
        else
        {
            // Complex object - would need deserialization
            sb.AppendLine($"        var {varName} = ParseComplexObject<{param.Type}>(query, \"{queryKey}\");");
        }
    }

    private static void GenerateUtilityMethods(StringBuilder sb)
    {
        sb.AppendLine("    private static int ParseInt32(string? value, int defaultValue = 0)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (string.IsNullOrEmpty(value)) return defaultValue;");
        sb.AppendLine("        if (int.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var result))");
        sb.AppendLine("            return result;");
        sb.AppendLine("        throw new FormatException($\"Unable to parse '{value}' as an integer.\");");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    private static int? ParseNullableInt32(string? value)");
        sb.AppendLine("    {");
        sb.AppendLine("        return int.TryParse(value, out var result) ? result : null;");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    private static long ParseInt64(string? value, long defaultValue = 0L)");
        sb.AppendLine("    {");
        sb.AppendLine("        return long.TryParse(value, out var result) ? result : defaultValue;");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    private static bool ParseBoolean(string? value, bool defaultValue = false)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (string.IsNullOrEmpty(value)) return defaultValue;");
        sb.AppendLine("        return value.ToLowerInvariant() switch");
        sb.AppendLine("        {");
        sb.AppendLine("            \"true\" or \"1\" or \"yes\" or \"on\" or \"t\" or \"y\" => true,");
        sb.AppendLine("            \"false\" or \"0\" or \"no\" or \"off\" or \"f\" or \"n\" => false,");
        sb.AppendLine("            _ => bool.TryParse(value, out var result) ? result : ");
        sb.AppendLine("                 throw new FormatException($\"Unable to parse '{value}' as a boolean.\")");
        sb.AppendLine("        };");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    private static DateTime ParseDateTime(string? value, DateTime defaultValue)");
        sb.AppendLine("    {");
        sb.AppendLine("        return DateTime.TryParse(value, CultureInfo.InvariantCulture, DateTimeStyles.AdjustToUniversal, out var result) ? result : defaultValue;");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    private static DateTime? ParseNullableDateTime(string? value)");
        sb.AppendLine("    {");
        sb.AppendLine("        return DateTime.TryParse(value, CultureInfo.InvariantCulture, DateTimeStyles.AdjustToUniversal, out var result) ? result : null;");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    private static Guid ParseGuid(string? value, Guid defaultValue)");
        sb.AppendLine("    {");
        sb.AppendLine("        return Guid.TryParse(value, out var result) ? result : defaultValue;");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    private static decimal ParseDecimal(string? value, decimal defaultValue = 0m)");
        sb.AppendLine("    {");
        sb.AppendLine("        return decimal.TryParse(value, NumberStyles.Number, CultureInfo.InvariantCulture, out var result) ? result : defaultValue;");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    private static T ParseEnum<T>(string? value, T defaultValue) where T : struct, Enum");
        sb.AppendLine("    {");
        sb.AppendLine("        return Enum.TryParse<T>(value, true, out var result) ? result : defaultValue;");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    private static List<T> ParseCollection<T>(StringValues values)");
        sb.AppendLine("    {");
        sb.AppendLine("        var result = new List<T>();");
        sb.AppendLine("        foreach (var value in values)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (!string.IsNullOrEmpty(value))");
        sb.AppendLine("            {");
        sb.AppendLine("                try");
        sb.AppendLine("                {");
        sb.AppendLine("                    if (typeof(T) == typeof(string))");
        sb.AppendLine("                    {");
        sb.AppendLine("                        result.Add((T)(object)value);");
        sb.AppendLine("                    }");
        sb.AppendLine("                    else if (typeof(T) == typeof(int))");
        sb.AppendLine("                    {");
        sb.AppendLine("                        if (int.TryParse(value, out var intVal))");
        sb.AppendLine("                            result.Add((T)(object)intVal);");
        sb.AppendLine("                    }");
        sb.AppendLine("                    else if (typeof(T).IsEnum)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        if (Enum.TryParse(typeof(T), value, true, out var enumVal) && enumVal != null)");
        sb.AppendLine("                            result.Add((T)enumVal);");
        sb.AppendLine("                    }");
        sb.AppendLine("                }");
        sb.AppendLine("                catch");
        sb.AppendLine("                {");
        sb.AppendLine("                    // Skip invalid values");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine("        return result;");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    private static T ParseComplexObject<T>(IQueryCollection query, string prefix)");
        sb.AppendLine("    {");
        sb.AppendLine("        // In a full implementation, this would handle complex object binding");
        sb.AppendLine("        // For now, return default value");
        sb.AppendLine("        return Activator.CreateInstance<T>() ?? default(T)!;");
        sb.AppendLine("    }");
    }

    private static bool IsEnumType(string typeName)
    {
        // Simple heuristic - in full implementation would check if type is actually an enum
        return !IsBuiltInType(typeName) && !typeName.Contains('.') && char.IsUpper(typeName[0]);
    }

    private static bool IsCollectionType(string typeName)
    {
        return typeName.StartsWith("List<") || 
               typeName.StartsWith("IList<") || 
               typeName.StartsWith("ICollection<") || 
               typeName.StartsWith("IEnumerable<") ||
               typeName.EndsWith("[]");
    }

    private static string ExtractElementType(string collectionType)
    {
        if (collectionType.EndsWith("[]"))
        {
            return collectionType.Substring(0, collectionType.Length - 2);
        }
        
        var start = collectionType.IndexOf('<') + 1;
        var end = collectionType.LastIndexOf('>');
        return collectionType.Substring(start, end - start);
    }

    private static bool IsBuiltInType(string typeName)
    {
        return typeName switch
        {
            "string" or "int" or "long" or "bool" or "double" or "float" or "decimal" or "DateTime" or "Guid" => true,
            "int?" or "long?" or "bool?" or "double?" or "float?" or "decimal?" or "DateTime?" or "Guid?" => true,
            _ when typeName.StartsWith("System.") => true,
            _ => false
        };
    }

    private static bool IsNullableType(string typeName)
    {
        return typeName.EndsWith("?") || typeName == "string" || typeName.StartsWith("Nullable<");
    }
}