using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace AxiomEndpoints.SourceGenerators;

internal static class GrpcClientGenerator
{
    public static string GenerateUnifiedClient(
        ImmutableArray<EndpointInfo> endpoints,
        ImmutableArray<StreamingEndpointInfo> streamingEndpoints,
        CompilationInfo compilation)
    {
        var sb = new StringBuilder();

        // Generate header
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Net.Http;");
        sb.AppendLine("using System.Net.Http.Json;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Grpc.Core;");
        sb.AppendLine("using Grpc.Net.Client;");
        sb.AppendLine("using AxiomEndpoints.Core;");
        sb.AppendLine("using AxiomEndpoints.Core.Streaming;");
        sb.AppendLine();
        sb.AppendLine($"namespace {compilation.RootNamespace}.Client;");
        sb.AppendLine();

        // Generate unified client class
        GenerateUnifiedClientClass(sb, endpoints, streamingEndpoints, compilation);

        // Generate client options
        GenerateClientOptions(sb);

        return sb.ToString();
    }

    private static void GenerateUnifiedClientClass(
        StringBuilder sb,
        ImmutableArray<EndpointInfo> endpoints,
        ImmutableArray<StreamingEndpointInfo> streamingEndpoints,
        CompilationInfo compilation)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Unified client that automatically chooses HTTP or gRPC based on server support and client preferences");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[System.CodeDom.Compiler.GeneratedCode(\"AxiomEndpoints.SourceGenerators\", \"1.0.0\")]");
        sb.AppendLine("public partial class AxiomUnifiedClient : IDisposable");
        sb.AppendLine("{");
        sb.AppendLine("    private readonly HttpClient _httpClient;");
        sb.AppendLine("    private readonly GrpcChannel? _grpcChannel;");
        sb.AppendLine("    private readonly AxiomUnifiedClientOptions _options;");
        sb.AppendLine("    private readonly bool _ownsHttpClient;");
        sb.AppendLine();

        // Generate gRPC client fields
        var services = GetServiceNames(endpoints, streamingEndpoints);
        foreach (var serviceName in services)
        {
            sb.AppendLine($"    private readonly {serviceName}.{serviceName}Client? _{serviceName.ToCamelCase()}GrpcClient;");
        }

        sb.AppendLine();

        // Generate constructors
        GenerateConstructors(sb, services);

        // Generate methods for unary endpoints
        foreach (var endpoint in endpoints.Where(e => e.Kind == EndpointKind.Unary))
        {
            GenerateUnaryClientMethod(sb, endpoint);
        }

        // Generate methods for streaming endpoints
        foreach (var endpoint in streamingEndpoints)
        {
            GenerateStreamingClientMethod(sb, endpoint);
        }

        // Generate helper methods
        GenerateHelperMethods(sb);

        // Generate disposal
        GenerateDisposalMethod(sb);

        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void GenerateConstructors(StringBuilder sb, System.Collections.Generic.HashSet<string> services)
    {
        // Constructor with HttpClient only
        sb.AppendLine("    public AxiomUnifiedClient(HttpClient httpClient, AxiomUnifiedClientOptions? options = null)");
        sb.AppendLine("        : this(httpClient, false, options)");
        sb.AppendLine("    {");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Main constructor
        sb.AppendLine("    public AxiomUnifiedClient(string baseAddress, AxiomUnifiedClientOptions? options = null)");
        sb.AppendLine("        : this(new HttpClient { BaseAddress = new Uri(baseAddress) }, true, options)");
        sb.AppendLine("    {");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Internal constructor
        sb.AppendLine("    private AxiomUnifiedClient(HttpClient httpClient, bool ownsHttpClient, AxiomUnifiedClientOptions? options)");
        sb.AppendLine("    {");
        sb.AppendLine("        _httpClient = httpClient;");
        sb.AppendLine("        _ownsHttpClient = ownsHttpClient;");
        sb.AppendLine("        _options = options ?? new AxiomUnifiedClientOptions();");
        sb.AppendLine();
        sb.AppendLine("        if (_options.PreferGrpc && httpClient.BaseAddress != null)");
        sb.AppendLine("        {");
        sb.AppendLine("            _grpcChannel = GrpcChannel.ForAddress(httpClient.BaseAddress, new GrpcChannelOptions");
        sb.AppendLine("            {");
        sb.AppendLine("                HttpClient = httpClient,");
        sb.AppendLine("                MaxReceiveMessageSize = _options.MaxReceiveMessageSize,");
        sb.AppendLine("                MaxSendMessageSize = _options.MaxSendMessageSize");
        sb.AppendLine("            });");
        sb.AppendLine();

        foreach (var serviceName in services)
        {
            sb.AppendLine($"            _{serviceName.ToCamelCase()}GrpcClient = new {serviceName}.{serviceName}Client(_grpcChannel);");
        }

        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void GenerateUnaryClientMethod(StringBuilder sb, EndpointInfo endpoint)
    {
        var methodName = endpoint.TypeName.Replace("Endpoint", "");
        var returnType = $"Task<Result<{endpoint.ResponseType}>>";
        var serviceName = GetServiceName(endpoint);

        sb.AppendLine();
        sb.AppendLine($"    public async {returnType} {methodName}Async(");
        sb.AppendLine($"        {endpoint.RequestType} request,");
        sb.AppendLine($"        CancellationToken cancellationToken = default)");
        sb.AppendLine("    {");

        // Try gRPC first if available and preferred
        sb.AppendLine($"        if (_{serviceName.ToCamelCase()}GrpcClient != null && _options.PreferGrpc)");
        sb.AppendLine("        {");
        sb.AppendLine("            try");
        sb.AppendLine("            {");
        sb.AppendLine($"                var grpcResponse = await _{serviceName.ToCamelCase()}GrpcClient.{endpoint.TypeName}Async(");
        sb.AppendLine("                    request,");
        sb.AppendLine("                    cancellationToken: cancellationToken);");
        sb.AppendLine($"                return Result<{endpoint.ResponseType}>.Success(grpcResponse);");
        sb.AppendLine("            }");
        sb.AppendLine("            catch (RpcException ex) when (ex.StatusCode == StatusCode.Unimplemented)");
        sb.AppendLine("            {");
        sb.AppendLine("                // Fall back to HTTP");
        sb.AppendLine("            }");
        sb.AppendLine("            catch (RpcException ex)");
        sb.AppendLine("            {");
        sb.AppendLine($"                return Result<{endpoint.ResponseType}>.Failure(MapGrpcError(ex));");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();

        // HTTP fallback
        sb.AppendLine("        // HTTP implementation");
        sb.AppendLine("        try");
        sb.AppendLine("        {");

        if (endpoint.HttpMethod == "GET")
        {
            sb.AppendLine($"            var url = BuildUrl<{endpoint.RouteType}>(request);");
            sb.AppendLine($"            var response = await _httpClient.GetAsync(url, cancellationToken);");
        }
        else
        {
            sb.AppendLine($"            var url = GetEndpointUrl(\"{endpoint.TypeName}\");");
            sb.AppendLine($"            var response = await _httpClient.{endpoint.HttpMethod}AsJsonAsync(url, request, cancellationToken);");
        }

        sb.AppendLine("            response.EnsureSuccessStatusCode();");
        sb.AppendLine($"            var result = await response.Content.ReadFromJsonAsync<{endpoint.ResponseType}>(cancellationToken);");
        sb.AppendLine($"            return Result<{endpoint.ResponseType}>.Success(result!);");
        sb.AppendLine("        }");
        sb.AppendLine("        catch (HttpRequestException ex)");
        sb.AppendLine("        {");
        sb.AppendLine($"            return Result<{endpoint.ResponseType}>.Failure(new Error(\"HTTP_ERROR\", ex.Message));");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
    }

    private static void GenerateStreamingClientMethod(StringBuilder sb, StreamingEndpointInfo endpoint)
    {
        var methodName = endpoint.TypeName.Replace("Endpoint", "");
        var serviceName = GetServiceName(endpoint);

        switch (endpoint.Mode)
        {
            case StreamingMode.ServerStream:
                GenerateServerStreamMethod(sb, endpoint, methodName, serviceName);
                break;
            case StreamingMode.ClientStream:
                GenerateClientStreamMethod(sb, endpoint, methodName, serviceName);
                break;
            case StreamingMode.Bidirectional:
                GenerateBidirectionalStreamMethod(sb, endpoint, methodName, serviceName);
                break;
        }
    }

    private static void GenerateServerStreamMethod(StringBuilder sb, StreamingEndpointInfo endpoint, string methodName, string serviceName)
    {
        sb.AppendLine();
        sb.AppendLine($"    public async IAsyncEnumerable<{endpoint.ResponseType}> {methodName}StreamAsync(");
        sb.AppendLine($"        {endpoint.RequestType} request,");
        sb.AppendLine($"        [EnumeratorCancellation] CancellationToken cancellationToken = default)");
        sb.AppendLine("    {");
        
        // Try gRPC first
        sb.AppendLine($"        if (_{serviceName.ToCamelCase()}GrpcClient != null && _options.PreferGrpc)");
        sb.AppendLine("        {");
        sb.AppendLine("            using var call = _grpcClient.StreamTodos(request, cancellationToken: cancellationToken);");
        sb.AppendLine("            await foreach (var item in call.ResponseStream.ReadAllAsync(cancellationToken))");
        sb.AppendLine("            {");
        sb.AppendLine("                yield return item;");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine("        else");
        sb.AppendLine("        {");
        sb.AppendLine("            // HTTP/SSE implementation would go here");
        sb.AppendLine("            throw new NotSupportedException(\"HTTP streaming not implemented in this example\");");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
    }

    private static void GenerateClientStreamMethod(StringBuilder sb, StreamingEndpointInfo endpoint, string methodName, string serviceName)
    {
        sb.AppendLine();
        sb.AppendLine($"    public async Task<{endpoint.ResponseType}> {methodName}StreamAsync(");
        sb.AppendLine($"        IAsyncEnumerable<{endpoint.RequestType}> requests,");
        sb.AppendLine($"        CancellationToken cancellationToken = default)");
        sb.AppendLine("    {");
        sb.AppendLine($"        if (_{serviceName.ToCamelCase()}GrpcClient == null)");
        sb.AppendLine("        {");
        sb.AppendLine("            throw new NotSupportedException(\"Client streaming requires gRPC support\");");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine($"        using var call = _{serviceName.ToCamelCase()}GrpcClient.{endpoint.TypeName}();");
        sb.AppendLine("        await foreach (var request in requests.WithCancellation(cancellationToken))");
        sb.AppendLine("        {");
        sb.AppendLine("            await call.RequestStream.WriteAsync(request);");
        sb.AppendLine("        }");
        sb.AppendLine("        await call.RequestStream.CompleteAsync();");
        sb.AppendLine("        return await call;");
        sb.AppendLine("    }");
    }

    private static void GenerateBidirectionalStreamMethod(StringBuilder sb, StreamingEndpointInfo endpoint, string methodName, string serviceName)
    {
        sb.AppendLine();
        sb.AppendLine($"    public async IAsyncEnumerable<{endpoint.ResponseType}> {methodName}StreamAsync(");
        sb.AppendLine($"        IAsyncEnumerable<{endpoint.RequestType}> requests,");
        sb.AppendLine($"        [EnumeratorCancellation] CancellationToken cancellationToken = default)");
        sb.AppendLine("    {");
        sb.AppendLine($"        if (_{serviceName.ToCamelCase()}GrpcClient == null)");
        sb.AppendLine("        {");
        sb.AppendLine("            throw new NotSupportedException(\"Bidirectional streaming requires gRPC support\");");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine($"        using var call = _{serviceName.ToCamelCase()}GrpcClient.{endpoint.TypeName}();");
        sb.AppendLine();
        sb.AppendLine("        // Start writing requests");
        sb.AppendLine("        _ = Task.Run(async () =>");
        sb.AppendLine("        {");
        sb.AppendLine("            await foreach (var request in requests.WithCancellation(cancellationToken))");
        sb.AppendLine("            {");
        sb.AppendLine("                await call.RequestStream.WriteAsync(request);");
        sb.AppendLine("            }");
        sb.AppendLine("            await call.RequestStream.CompleteAsync();");
        sb.AppendLine("        }, cancellationToken);");
        sb.AppendLine();
        sb.AppendLine("        // Read responses");
        sb.AppendLine("        await foreach (var response in call.ResponseStream.ReadAllAsync(cancellationToken))");
        sb.AppendLine("        {");
        sb.AppendLine("            yield return response;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
    }

    private static void GenerateHelperMethods(StringBuilder sb)
    {
        sb.AppendLine();
        sb.AppendLine("    private Error MapGrpcError(RpcException ex)");
        sb.AppendLine("    {");
        sb.AppendLine("        var errorType = ex.StatusCode switch");
        sb.AppendLine("        {");
        sb.AppendLine("            StatusCode.NotFound => ErrorType.NotFound,");
        sb.AppendLine("            StatusCode.InvalidArgument => ErrorType.Validation,");
        sb.AppendLine("            StatusCode.Unauthenticated => ErrorType.Unauthorized,");
        sb.AppendLine("            StatusCode.PermissionDenied => ErrorType.Forbidden,");
        sb.AppendLine("            StatusCode.AlreadyExists => ErrorType.Conflict,");
        sb.AppendLine("            StatusCode.ResourceExhausted => ErrorType.TooManyRequests,");
        sb.AppendLine("            _ => ErrorType.Internal");
        sb.AppendLine("        };");
        sb.AppendLine();
        sb.AppendLine("        return new Error($\"GRPC_{ex.StatusCode}\", ex.Status.Detail ?? \"gRPC error\", errorType);");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    private string GetEndpointUrl(string endpointName)");
        sb.AppendLine("    {");
        sb.AppendLine("        // Simple URL generation - in a real implementation this would use route templates");
        sb.AppendLine("        return $\"/api/{endpointName.ToLowerInvariant()}\";");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    private string BuildUrl<TRoute>(object request) where TRoute : IRoute<TRoute>");
        sb.AppendLine("    {");
        sb.AppendLine("        // Route building implementation - simplified for this example");
        sb.AppendLine("        return \"/api/\" + typeof(TRoute).Name.ToLowerInvariant();");
        sb.AppendLine("    }");
    }

    private static void GenerateDisposalMethod(StringBuilder sb)
    {
        sb.AppendLine();
        sb.AppendLine("    public void Dispose()");
        sb.AppendLine("    {");
        sb.AppendLine("        _grpcChannel?.Dispose();");
        sb.AppendLine("        if (_ownsHttpClient)");
        sb.AppendLine("        {");
        sb.AppendLine("            _httpClient?.Dispose();");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
    }

    private static void GenerateClientOptions(StringBuilder sb)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Configuration options for the unified Axiom client");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public class AxiomUnifiedClientOptions");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Whether to prefer gRPC over HTTP when both are available");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public bool PreferGrpc { get; set; } = true;");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Maximum message size for gRPC receives (null for default)");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public int? MaxReceiveMessageSize { get; set; } = 10 * 1024 * 1024; // 10MB");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Maximum message size for gRPC sends (null for default)");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public int? MaxSendMessageSize { get; set; } = 10 * 1024 * 1024; // 10MB");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Timeout for gRPC calls");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public TimeSpan? GrpcTimeout { get; set; }");
        sb.AppendLine("}");
    }

    private static System.Collections.Generic.HashSet<string> GetServiceNames(
        ImmutableArray<EndpointInfo> endpoints,
        ImmutableArray<StreamingEndpointInfo> streamingEndpoints)
    {
        var services = new System.Collections.Generic.HashSet<string>();

        foreach (var endpoint in endpoints)
        {
            services.Add(GetServiceName(endpoint));
        }

        foreach (var endpoint in streamingEndpoints)
        {
            services.Add(GetServiceName(endpoint));
        }

        return services;
    }

    private static string GetServiceName(EndpointInfo endpoint)
    {
        var parts = endpoint.Namespace.Split('.');
        var serviceName = parts.Length > 1 ? parts[parts.Length - 1] : "DefaultService";
        
        if (!serviceName.EndsWith("Service", StringComparison.OrdinalIgnoreCase))
        {
            serviceName += "Service";
        }

        return serviceName;
    }

    private static string GetServiceName(StreamingEndpointInfo endpoint)
    {
        var parts = endpoint.Namespace.Split('.');
        var serviceName = parts.Length > 1 ? parts[parts.Length - 1] : "DefaultService";
        
        if (!serviceName.EndsWith("Service", StringComparison.OrdinalIgnoreCase))
        {
            serviceName += "Service";
        }

        return serviceName;
    }
}

// Extension method for ToCamelCase
internal static class StringExtensions
{
    public static string ToCamelCase(this string input)
    {
        if (string.IsNullOrEmpty(input) || input.Length == 1)
            return input.ToLowerInvariant();

        return char.ToLowerInvariant(input[0]) + input.Substring(1);
    }
}