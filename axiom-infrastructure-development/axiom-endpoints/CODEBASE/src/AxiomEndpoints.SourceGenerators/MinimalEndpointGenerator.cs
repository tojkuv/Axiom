using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace AxiomEndpoints.SourceGenerators;

internal static class MinimalEndpointGenerator
{
    public static string GenerateMinimalEndpoints(
        ImmutableArray<MinimalEndpointInfo> minimalEndpoints,
        CompilationInfo compilation)
    {
        if (minimalEndpoints.IsEmpty)
            return string.Empty;

        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Frozen;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Microsoft.AspNetCore.Builder;");
        sb.AppendLine("using Microsoft.AspNetCore.Http;");
        sb.AppendLine("using Microsoft.AspNetCore.Mvc;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using AxiomEndpoints.Core;");
        sb.AppendLine("using AxiomEndpoints.Core.Attributes;");
        sb.AppendLine();
        sb.AppendLine($"namespace {compilation.RootNamespace}.Generated;");
        sb.AppendLine();

        foreach (var endpoint in minimalEndpoints)
        {
            GenerateEndpointClass(sb, endpoint, compilation);
            GenerateRouteClass(sb, endpoint, compilation);
        }

        // Generate registration helper
        GenerateMinimalEndpointRegistration(sb, minimalEndpoints, compilation);

        return sb.ToString();
    }

    private static void GenerateEndpointClass(StringBuilder sb, MinimalEndpointInfo endpoint, CompilationInfo compilation)
    {
        var endpointName = $"{endpoint.MethodName}_Generated";
        var routeType = $"{endpoint.MethodName}_Route";

        sb.AppendLine($"[System.CodeDom.Compiler.GeneratedCode(\"AxiomEndpoints.SourceGenerators\", \"1.0.0\")]");
        sb.AppendLine($"public class {endpointName} : IAxiom<{routeType}, {endpoint.ReturnType}>");
        sb.AppendLine("{");
        sb.AppendLine($"    public static HttpMethod HttpMethod => HttpMethod.{endpoint.HttpMethod};");
        sb.AppendLine();

        // Generate constructor with dependencies
        if (endpoint.Dependencies.Length > 0)
        {
            foreach (var dep in endpoint.Dependencies)
            {
                sb.AppendLine($"    private readonly {dep.Type} _{dep.Name};");
            }
            sb.AppendLine();
            sb.AppendLine($"    public {endpointName}({string.Join(", ", endpoint.Dependencies.Select(d => $"{d.Type} {d.Name}"))})");
            sb.AppendLine("    {");
            foreach (var dep in endpoint.Dependencies)
            {
                sb.AppendLine($"        _{dep.Name} = {dep.Name};");
            }
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        // Generate HandleAsync method
        sb.AppendLine($"    public async ValueTask<Result<{endpoint.ReturnType}>> HandleAsync({routeType} request, IContext context)");
        sb.AppendLine("    {");

        // Generate parameter mapping
        var methodParams = new List<string>();
        foreach (var param in endpoint.Parameters)
        {
            if (param.BindingType == ParameterBindingType.Route)
            {
                methodParams.Add($"request.{param.Name}");
            }
            else if (param.BindingType == ParameterBindingType.Query)
            {
                methodParams.Add($"request.{param.Name}");
            }
            else if (param.BindingType == ParameterBindingType.Body)
            {
                methodParams.Add($"request.Body");
            }
            else if (param.BindingType == ParameterBindingType.Service)
            {
                methodParams.Add($"_{param.Name}");
            }
            else
            {
                methodParams.Add($"request.{param.Name}");
            }
        }

        methodParams.Add("context.CancellationToken");

        sb.AppendLine($"        var result = await {endpoint.ContainingType}.{endpoint.MethodName}({string.Join(", ", methodParams)});");
        sb.AppendLine("        return result;");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void GenerateRouteClass(StringBuilder sb, MinimalEndpointInfo endpoint, CompilationInfo compilation)
    {
        var routeType = $"{endpoint.MethodName}_Route";

        sb.AppendLine($"[System.CodeDom.Compiler.GeneratedCode(\"AxiomEndpoints.SourceGenerators\", \"1.0.0\")]");
        sb.AppendLine($"public class {routeType} : IRoute<{routeType}>");
        sb.AppendLine("{");

        // Generate properties for route, query, and body parameters
        foreach (var param in endpoint.Parameters)
        {
            if (param.BindingType != ParameterBindingType.Service)
            {
                sb.AppendLine($"    public {param.Type} {param.Name} {{ get; set; }}");
            }
        }

        // Special handling for body parameters
        var bodyParams = endpoint.Parameters.Where(p => p.BindingType == ParameterBindingType.Body).ToArray();
        if (bodyParams.Length > 0)
        {
            var bodyParam = bodyParams[0];
            sb.AppendLine($"    public {bodyParam.Type} Body {{ get; set; }}");
        }

        // Add required Metadata property
        sb.AppendLine();
        sb.AppendLine("    public static FrozenDictionary<string, object> Metadata { get; } = ");
        sb.AppendLine("        FrozenDictionary<string, object>.Empty;");

        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void GenerateMinimalEndpointRegistration(StringBuilder sb, ImmutableArray<MinimalEndpointInfo> endpoints, CompilationInfo compilation)
    {
        sb.AppendLine($"[System.CodeDom.Compiler.GeneratedCode(\"AxiomEndpoints.SourceGenerators\", \"1.0.0\")]");
        sb.AppendLine("public static class MinimalEndpointRegistration");
        sb.AppendLine("{");
        sb.AppendLine("    public static void RegisterMinimalEndpoints(IServiceCollection services)");
        sb.AppendLine("    {");

        foreach (var endpoint in endpoints)
        {
            var endpointName = $"{endpoint.MethodName}_Generated";
            sb.AppendLine($"        services.AddScoped<{endpointName}>();");
        }

        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    public static void MapMinimalEndpoints(WebApplication app)");
        sb.AppendLine("    {");

        foreach (var endpoint in endpoints)
        {
            GenerateEndpointMapping(sb, endpoint);
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");
    }

    private static void GenerateEndpointMapping(StringBuilder sb, MinimalEndpointInfo endpoint)
    {
        var endpointName = $"{endpoint.MethodName}_Generated";
        var routeType = $"{endpoint.MethodName}_Route";
        var method = endpoint.HttpMethod;
        var hasQueryParams = endpoint.Parameters.Any(p => p.BindingType == ParameterBindingType.Query);

        if (hasQueryParams)
        {
            // Use custom query parameter binding
            sb.AppendLine($"        app.Map{method}(\"{endpoint.RouteTemplate}\", async (");
            sb.AppendLine($"            HttpContext httpContext,");
            sb.AppendLine($"            {endpointName} endpoint,");
            sb.AppendLine($"            IContext context) =>");
            sb.AppendLine("        {");
            sb.AppendLine("            try");
            sb.AppendLine("            {");
            sb.AppendLine($"                var route = QueryParameterBinder.Bind{endpoint.MethodName}Parameters(httpContext);");
            sb.AppendLine("                var result = await endpoint.HandleAsync(route, context);");
            sb.AppendLine("                return result.Match(");
            sb.AppendLine("                    success: value => Results.Ok(value),");
            sb.AppendLine("                    failure: error => error.Type switch");
            sb.AppendLine("                    {");
            sb.AppendLine("                        ErrorType.NotFound => Results.NotFound(error),");
            sb.AppendLine("                        ErrorType.Validation => Results.BadRequest(error),");
            sb.AppendLine("                        ErrorType.Unauthorized => Results.Unauthorized(),");
            sb.AppendLine("                        ErrorType.Forbidden => Results.Forbid(),");
            sb.AppendLine("                        _ => Results.Problem(error.Message)");
            sb.AppendLine("                    });");
            sb.AppendLine("            }");
            sb.AppendLine("            catch (ArgumentException ex)");
            sb.AppendLine("            {");
            sb.AppendLine("                return Results.BadRequest(new { error = ex.Message });");
            sb.AppendLine("            }");
            sb.AppendLine("            catch (FormatException ex)");
            sb.AppendLine("            {");
            sb.AppendLine("                return Results.BadRequest(new { error = ex.Message });");
            sb.AppendLine("            }");
            sb.AppendLine("        })");
        }
        else
        {
            // Use standard ASP.NET Core parameter binding
            sb.AppendLine($"        app.Map{method}(\"{endpoint.RouteTemplate}\", async (");
            sb.AppendLine($"            [AsParameters] {routeType} route,");
            sb.AppendLine($"            {endpointName} endpoint,");
            sb.AppendLine($"            IContext context,");
            sb.AppendLine($"            CancellationToken cancellationToken) =>");
            sb.AppendLine("        {");
            sb.AppendLine("            var result = await endpoint.HandleAsync(route, context);");
            sb.AppendLine("            return result.Match(");
            sb.AppendLine("                success: value => Results.Ok(value),");
            sb.AppendLine("                failure: error => error.Type switch");
            sb.AppendLine("                {");
            sb.AppendLine("                    ErrorType.NotFound => Results.NotFound(error),");
            sb.AppendLine("                    ErrorType.Validation => Results.BadRequest(error),");
            sb.AppendLine("                    ErrorType.Unauthorized => Results.Unauthorized(),");
            sb.AppendLine("                    ErrorType.Forbidden => Results.Forbid(),");
            sb.AppendLine("                    _ => Results.Problem(error.Message)");
            sb.AppendLine("                });");
            sb.AppendLine("        })");
        }

        // Add metadata
        if (endpoint.RequiresAuth)
        {
            sb.AppendLine("        .RequireAuthorization()");
        }

        if (!string.IsNullOrEmpty(endpoint.Name))
        {
            sb.AppendLine($"        .WithName(\"{endpoint.Name}\")");
        }

        if (endpoint.Tags?.Length > 0)
        {
            sb.AppendLine($"        .WithTags({string.Join(", ", endpoint.Tags.Select(t => $"\"{t}\""))})");
        }

        if (!string.IsNullOrEmpty(endpoint.Summary))
        {
            sb.AppendLine($"        .WithSummary(\"{endpoint.Summary}\")");
        }

        sb.AppendLine(";");
        sb.AppendLine();
    }

    public static MinimalEndpointInfo? GetMinimalEndpointInfo(GeneratorSyntaxContext context)
    {
        try
        {
            if (context.Node is not MethodDeclarationSyntax method)
                return null;

            var model = context.SemanticModel;
            var methodSymbol = model.GetDeclaredSymbol(method) as IMethodSymbol;

            if (methodSymbol is null || !methodSymbol.IsStatic)
                return null;

            // Check for HTTP method attributes - simplified approach
            var httpMethodAttr = methodSymbol.GetAttributes()
                .FirstOrDefault(attr => IsHttpMethodAttribute(attr));

            if (httpMethodAttr is null)
                return null;

            // Simplified attribute processing to avoid InvalidOperationException
            var routeTemplate = "";
            var httpMethod = "GET";
            
            try
            {
                // Safely extract route template
                if (httpMethodAttr.ConstructorArguments.Length > 0)
                {
                    var firstArg = httpMethodAttr.ConstructorArguments[0];
                    if (firstArg.Value != null)
                        routeTemplate = firstArg.Value.ToString();
                }
                
                // Get HTTP method from attribute type name
                httpMethod = GetHttpMethodFromAttribute(httpMethodAttr);
            }
            catch
            {
                // If attribute processing fails, use defaults
                routeTemplate = "/api/unknown";
                httpMethod = "GET";
            }

            // Create basic parameter info without complex processing
            var parameters = methodSymbol.Parameters
                .Where(p => p.Type.Name != "CancellationToken")
                .Select(param => new MinimalEndpointParameter
                {
                    Name = param.Name,
                    Type = param.Type.ToDisplayString(),
                    BindingType = GetSimpleParameterBindingType(param),
                    HasDefaultValue = param.HasExplicitDefaultValue,
                    DefaultValue = "default"
                })
                .ToImmutableArray();

            // Extract service dependencies
            var dependencies = parameters
                .Where(p => p.BindingType == ParameterBindingType.Service)
                .Select(p => new ServiceDependency
                {
                    Name = p.Name,
                    Type = p.Type
                })
                .ToImmutableArray();

            return new MinimalEndpointInfo
            {
                MethodName = methodSymbol.Name,
                ContainingType = methodSymbol.ContainingType?.ToDisplayString() ?? "Unknown",
                RouteTemplate = routeTemplate,
                HttpMethod = httpMethod,
                ReturnType = ExtractReturnType(methodSymbol.ReturnType),
                Parameters = parameters,
                Dependencies = dependencies,
                RequiresAuth = false,
                Name = null,
                Tags = new string[0],
                Summary = ""
            };
        }
        catch
        {
            // If anything fails, return null to avoid crashing the generator
            return null;
        }
    }

    private static bool IsHttpMethodAttribute(AttributeData attr)
    {
        var typeName = attr.AttributeClass?.Name;
        var fullName = attr.AttributeClass?.ToDisplayString();
        
        // Check both short name and full name to be more robust
        return typeName is "GetAttribute" or "PostAttribute" or "PutAttribute" or "DeleteAttribute" or "PatchAttribute" ||
               fullName is "AxiomEndpoints.Core.Attributes.GetAttribute" or 
                         "AxiomEndpoints.Core.Attributes.PostAttribute" or 
                         "AxiomEndpoints.Core.Attributes.PutAttribute" or 
                         "AxiomEndpoints.Core.Attributes.DeleteAttribute" or 
                         "AxiomEndpoints.Core.Attributes.PatchAttribute";
    }

    private static string GetHttpMethodFromAttribute(AttributeData attr)
    {
        return attr.AttributeClass?.Name switch
        {
            "GetAttribute" => "Get",
            "PostAttribute" => "Post",
            "PutAttribute" => "Put",
            "DeleteAttribute" => "Delete",
            "PatchAttribute" => "Patch",
            _ => "Get"
        };
    }

    private static ParameterBindingType GetParameterBindingType(IParameterSymbol param)
    {
        // Check for binding attributes
        var attributes = param.GetAttributes();
        
        if (attributes.Any(a => a.AttributeClass?.Name == "FromQueryAttribute"))
            return ParameterBindingType.Query;
        
        if (attributes.Any(a => a.AttributeClass?.Name == "FromRouteAttribute"))
            return ParameterBindingType.Route;
        
        if (attributes.Any(a => a.AttributeClass?.Name == "FromBodyAttribute"))
            return ParameterBindingType.Body;
        
        if (attributes.Any(a => a.AttributeClass?.Name == "FromServicesAttribute"))
            return ParameterBindingType.Service;
        
        if (param.Type.Name == "CancellationToken")
            return ParameterBindingType.CancellationToken;

        // Default binding based on parameter type and HTTP method
        if (IsServiceType(param.Type))
            return ParameterBindingType.Service;
        
        if (IsSimpleType(param.Type))
            return ParameterBindingType.Query;
        
        return ParameterBindingType.Body;
    }

    private static bool IsServiceType(ITypeSymbol type)
    {
        var typeName = type.ToDisplayString();
        return typeName.Contains("DbContext") || 
               typeName.Contains("ILogger") || 
               typeName.Contains("IConfiguration") ||
               typeName.StartsWith("I") && char.IsUpper(typeName[1]);
    }

    private static bool IsSimpleType(ITypeSymbol type)
    {
        return type.SpecialType is 
            SpecialType.System_String or 
            SpecialType.System_Int32 or 
            SpecialType.System_Int64 or 
            SpecialType.System_Boolean or 
            SpecialType.System_DateTime or
            SpecialType.System_Decimal or
            SpecialType.System_Double;
    }

    private static string ExtractReturnType(ITypeSymbol returnType)
    {
        // Handle Task<Result<T>> pattern
        if (returnType is INamedTypeSymbol namedType && namedType.IsGenericType)
        {
            if (namedType.Name == "Task" && namedType.TypeArguments.Length == 1)
            {
                var taskInnerType = namedType.TypeArguments[0];
                if (taskInnerType is INamedTypeSymbol resultType && 
                    resultType.Name == "Result" && 
                    resultType.TypeArguments.Length == 1)
                {
                    return resultType.TypeArguments[0].ToDisplayString();
                }
                return taskInnerType.ToDisplayString();
            }
        }
        
        return returnType.ToDisplayString();
    }

    private static bool HasAuthorizeAttribute(IMethodSymbol method)
    {
        return method.GetAttributes().Any(a => a.AttributeClass?.Name == "AuthorizeAttribute");
    }

    private static ParameterBindingType GetSimpleParameterBindingType(IParameterSymbol param)
    {
        try
        {
            // Check for binding attributes with simple name matching
            var attributes = param.GetAttributes();
            
            foreach (var attr in attributes)
            {
                var attrName = attr.AttributeClass?.Name;
                if (attrName == "FromQueryAttribute") return ParameterBindingType.Query;
                if (attrName == "FromRouteAttribute") return ParameterBindingType.Route;
                if (attrName == "FromBodyAttribute") return ParameterBindingType.Body;
                if (attrName == "FromServicesAttribute") return ParameterBindingType.Service;
            }
            
            // Default binding based on parameter type
            var typeName = param.Type.ToDisplayString();
            if (typeName.Contains("DbContext") || typeName.Contains("ILogger") || typeName.Contains("IConfiguration"))
                return ParameterBindingType.Service;
            
            if (param.Type.SpecialType is 
                SpecialType.System_String or 
                SpecialType.System_Int32 or 
                SpecialType.System_Int64 or 
                SpecialType.System_Boolean or 
                SpecialType.System_DateTime or
                SpecialType.System_Decimal or
                SpecialType.System_Double)
                return ParameterBindingType.Query;
            
            return ParameterBindingType.Body;
        }
        catch
        {
            return ParameterBindingType.Query;
        }
    }
}

public class MinimalEndpointInfo
{
    public string MethodName { get; set; } = "";
    public string ContainingType { get; set; } = "";
    public string RouteTemplate { get; set; } = "";
    public string HttpMethod { get; set; } = "";
    public string ReturnType { get; set; } = "";
    public ImmutableArray<MinimalEndpointParameter> Parameters { get; set; }
    public ImmutableArray<ServiceDependency> Dependencies { get; set; }
    public bool RequiresAuth { get; set; }
    public string? Name { get; set; }
    public string[]? Tags { get; set; }
    public string? Summary { get; set; }
}

public class MinimalEndpointParameter
{
    public string Name { get; set; } = "";
    public string Type { get; set; } = "";
    public ParameterBindingType BindingType { get; set; }
    public bool HasDefaultValue { get; set; }
    public string DefaultValue { get; set; } = "";
}

public class ServiceDependency
{
    public string Name { get; set; } = "";
    public string Type { get; set; } = "";
}

public enum ParameterBindingType
{
    Query,
    Route,
    Body,
    Service,
    Header,
    CancellationToken
}