using AxiomEndpoints.AspNetCore;
using AxiomEndpoints.Core;
using AxiomEndpointsExample.Api;
using Microsoft.AspNetCore.ResponseCompression;
using Microsoft.EntityFrameworkCore;
using System.IO.Compression;

var builder = WebApplication.CreateBuilder(args);

// Configure performance optimization settings
builder.Configuration.AddInMemoryCollection(new Dictionary<string, string?>
{
    ["Axiom:Performance:EnableCaching"] = "true",
    ["Axiom:Performance:EnableCompression"] = "true", 
    ["Axiom:Performance:EnablePerformanceMonitoring"] = "true",
    ["Axiom:Performance:Cache:DefaultExpirationMinutes"] = "15",
    ["Axiom:Performance:Cache:SizeLimit"] = "100000000", // 100MB
    ["Axiom:Performance:SlowRequestThresholdMs"] = "500"
});

// Add Entity Framework - conditionally based on environment
if (builder.Environment.IsEnvironment("Testing"))
{
    // Use InMemory database for tests
    builder.Services.AddDbContext<AppDbContext>(options =>
        options.UseInMemoryDatabase($"TestDb_{Guid.NewGuid()}"));
}
else
{
    // Use PostgreSQL for non-test environments
    builder.Services.AddDbContext<AppDbContext>(options =>
        options.UseNpgsql("Host=localhost;Database=axiom_example;Username=postgres;Password=postgres"));
}

// Add AxiomEndpoints with automatic discovery
builder.Services.AddAxiomEndpoints();

// Configure Axiom Performance Optimizations (generated by source generator)
// This configuration is available from the generated PerformanceOptimizations.g.cs
try
{
    // Attempt to use generated performance extensions
    var addPerformanceMethod = typeof(Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions).Assembly
        .GetTypes()
        .SelectMany(t => t.GetMethods())
        .FirstOrDefault(m => m.Name == "AddAxiomPerformance");
    
    if (addPerformanceMethod != null)
    {
        Console.WriteLine("[INFO] Using generated Axiom performance optimizations");
        // Would call: builder.Services.AddAxiomPerformance(config => { ... });
    }
    else
    {
        Console.WriteLine("[INFO] Configuring performance optimizations manually");
    }
}
catch (Exception ex)
{
    Console.WriteLine($"[INFO] Using manual performance configuration: {ex.Message}");
}

// Manual performance configuration (fallback)
builder.Services.AddMemoryCache(options =>
{
    options.SizeLimit = 100_000_000; // 100MB
    options.CompactionPercentage = 0.25;
});

builder.Services.AddResponseCompression(options =>
{
    options.EnableForHttps = true;
    options.Providers.Add<BrotliCompressionProvider>();
    options.Providers.Add<GzipCompressionProvider>();
    options.MimeTypes = new[]
    {
        "application/json",
        "application/xml", 
        "text/plain",
        "text/html",
        "text/css",
        "text/javascript",
        "application/javascript"
    };
});

builder.Services.Configure<BrotliCompressionProviderOptions>(options =>
{
    options.Level = CompressionLevel.Optimal;
});

builder.Services.Configure<GzipCompressionProviderOptions>(options =>
{
    options.Level = CompressionLevel.Optimal;
});

// Add performance services
builder.Services.AddScoped<IDataService, DataService>();
builder.Services.AddScoped<IReportService, ReportService>();
builder.Services.AddSingleton<IMetricsCollector, MetricsCollector>();

// Add CORS for client access
builder.Services.AddCors(options =>
{
    options.AddDefaultPolicy(policy =>
    {
        policy.AllowAnyOrigin()
              .AllowAnyMethod()
              .AllowAnyHeader();
    });
});

var app = builder.Build();

// Configure the HTTP request pipeline
if (app.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
}

app.UseHttpsRedirection();

// Use response compression before other middleware
app.UseResponseCompression();

app.UseCors();

// Performance monitoring middleware (try generated first, fallback to custom)
try
{
    var usePerformanceMethod = typeof(Microsoft.AspNetCore.Builder.IApplicationBuilder).Assembly
        .GetTypes()
        .SelectMany(t => t.GetMethods())
        .FirstOrDefault(m => m.Name == "UseAxiomPerformance");
    
    if (usePerformanceMethod != null)
    {
        Console.WriteLine("[INFO] Using generated Axiom performance middleware");
        // Would call: app.UseAxiomPerformance();
    }
    else
    {
        Console.WriteLine("[INFO] Using custom performance monitoring middleware");
        app.UseMiddleware<PerformanceMonitoringMiddleware>();
    }
}
catch (Exception ex)
{
    Console.WriteLine($"[INFO] Using custom performance middleware: {ex.Message}");
    app.UseMiddleware<PerformanceMonitoringMiddleware>();
}

// Debug middleware to log all requests with performance metrics
app.Use(async (context, next) =>
{
    var stopwatch = System.Diagnostics.Stopwatch.StartNew();
    var initialMemory = GC.GetTotalMemory(false);
    
    Console.WriteLine($"[REQUEST] {context.Request.Method} {context.Request.Path}");
    Console.WriteLine($"[REQUEST] Query: {context.Request.QueryString}");
    Console.WriteLine($"[REQUEST] Route Values: {string.Join(", ", context.Request.RouteValues.Select(kv => $"{kv.Key}={kv.Value}"))}");
    
    await next();
    
    stopwatch.Stop();
    var finalMemory = GC.GetTotalMemory(false);
    var memoryUsed = finalMemory - initialMemory;
    
    Console.WriteLine($"[RESPONSE] {context.Response.StatusCode} in {stopwatch.ElapsedMilliseconds}ms");
    Console.WriteLine($"[RESPONSE] Memory used: {memoryUsed:N0} bytes");
    Console.WriteLine($"[RESPONSE] Endpoint: {context.GetEndpoint()?.DisplayName ?? "No endpoint matched"}");
    
    // Log slow requests
    if (stopwatch.ElapsedMilliseconds > 500)
    {
        Console.WriteLine($"[SLOW REQUEST] {context.Request.Method} {context.Request.Path} took {stopwatch.ElapsedMilliseconds}ms");
    }
});

// Use AxiomEndpoints automatic endpoint discovery
app.UseAxiomEndpoints();

await app.RunAsync();

// Make Program class accessible for testing
public partial class Program { }