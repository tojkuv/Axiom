using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;

namespace AxiomEndpoints.SourceGenerators;

internal static class AdvancedRouteGenerator
{
    public static void GenerateRouteMetadata(
        SourceProductionContext context,
        ImmutableArray<AdvancedRouteInfo> routes,
        CompilationInfo compilation)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System.Collections.Frozen;");
        sb.AppendLine("using AxiomEndpoints.Core;");
        sb.AppendLine("using AxiomEndpoints.Routing;");
        sb.AppendLine();
        sb.AppendLine($"namespace {compilation.RootNamespace}.Generated;");
        sb.AppendLine();
        sb.AppendLine("[System.CodeDom.Compiler.GeneratedCode(\"AxiomEndpoints.SourceGenerators\", \"1.0.0\")]");
        sb.AppendLine("internal static partial class RouteMetadata");
        sb.AppendLine("{");

        GenerateConstraintValidation(sb, routes);
        GenerateQueryParameterMetadata(sb, routes);
        GenerateRouteEndpoints(sb, routes);
        GenerateVersionedRoutes(sb, routes);
        GenerateAlternativeRoutes(sb, routes);

        sb.AppendLine("}");

        context.AddSource("AdvancedRouteMetadata.g.cs", sb.ToString());
    }

    private static void GenerateConstraintValidation(StringBuilder sb, ImmutableArray<AdvancedRouteInfo> routes)
    {
        sb.AppendLine("    public static bool ValidateRoute<TRoute>(TRoute route) where TRoute : IRoute<TRoute>");
        sb.AppendLine("    {");
        sb.AppendLine("        return typeof(TRoute).Name switch");
        sb.AppendLine("        {");

        foreach (var route in routes.Where(r => r.Constraints.Any()))
        {
            sb.AppendLine($"            nameof({route.FullTypeName}) => Validate{route.TypeName}(route),");
        }

        sb.AppendLine("            _ => true");
        sb.AppendLine("        };");
        sb.AppendLine("    }");
        sb.AppendLine();

        foreach (var route in routes.Where(r => r.Constraints.Any()))
        {
            GenerateRouteValidation(sb, route);
        }
    }

    private static void GenerateRouteValidation(StringBuilder sb, AdvancedRouteInfo route)
    {
        sb.AppendLine($"    private static bool Validate{route.TypeName}(object route)");
        sb.AppendLine("    {");
        sb.AppendLine($"        var typed = ({route.FullTypeName})route;");

        foreach (var constraint in route.Constraints)
        {
            sb.AppendLine($"        if (!{GenerateConstraintCheck(constraint)})");
            sb.AppendLine("            return false;");
        }

        sb.AppendLine("        return true;");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static string GenerateConstraintCheck(RouteConstraintInfo constraint)
    {
        return constraint.Type switch
        {
            "Range" => $"(typed.{constraint.ParameterName} >= {constraint.Min} && typed.{constraint.ParameterName} <= {constraint.Max})",
            "Regex" => $"System.Text.RegularExpressions.Regex.IsMatch(typed.{constraint.ParameterName}, @\"{constraint.Pattern}\")",
            "Length" => GenerateLengthCheck(constraint),
            "Enum" => GenerateEnumCheck(constraint),
            "AllowedValues" => GenerateAllowedValuesCheck(constraint),
            _ => "true"
        };
    }

    private static string GenerateLengthCheck(RouteConstraintInfo constraint)
    {
        if (!string.IsNullOrEmpty(constraint.Min) && !string.IsNullOrEmpty(constraint.Max))
        {
            return $"(typed.{constraint.ParameterName}?.Length >= {constraint.Min} && typed.{constraint.ParameterName}?.Length <= {constraint.Max})";
        }
        else if (!string.IsNullOrEmpty(constraint.Min))
        {
            return $"(typed.{constraint.ParameterName}?.Length >= {constraint.Min})";
        }
        else if (!string.IsNullOrEmpty(constraint.Max))
        {
            return $"(typed.{constraint.ParameterName}?.Length <= {constraint.Max})";
        }

        return "true";
    }

    private static string GenerateEnumCheck(RouteConstraintInfo constraint)
    {
        var values = string.Join("\", \"", constraint.AllowedValues);
        return $"new[] {{ \"{values}\" }}.Contains(typed.{constraint.ParameterName}?.ToString()?.ToLowerInvariant())";
    }

    private static string GenerateAllowedValuesCheck(RouteConstraintInfo constraint)
    {
        var values = string.Join("\", \"", constraint.AllowedValues);
        return $"new[] {{ \"{values}\" }}.Contains(typed.{constraint.ParameterName}?.ToString()?.ToLowerInvariant())";
    }

    private static void GenerateQueryParameterMetadata(StringBuilder sb, ImmutableArray<AdvancedRouteInfo> routes)
    {
        sb.AppendLine("    public static class QueryParameterMetadataProvider");
        sb.AppendLine("    {");

        foreach (var route in routes.Where(r => r.HasQueryParameters && r.QueryMetadata != null))
        {
            sb.AppendLine($"        public static QueryParameterMetadata Get{route.TypeName}Metadata()");
            sb.AppendLine("        {");
            sb.AppendLine("            return new QueryParameterMetadata");
            sb.AppendLine("            {");
            sb.AppendLine("                Parameters = new Dictionary<string, QueryParameterInfo>");
            sb.AppendLine("                {");

            foreach (var param in route.QueryMetadata?.Parameters ?? ImmutableArray<QueryParameterInfo>.Empty)
            {
                sb.AppendLine($"                    [\"{param.Name}\"] = new QueryParameterInfo");
                sb.AppendLine("                    {");
                sb.AppendLine($"                        Name = \"{param.Name}\",");
                sb.AppendLine($"                        Type = typeof({param.Type}),");
                sb.AppendLine($"                        IsRequired = {param.IsRequired.ToString().ToLowerInvariant()},");
                sb.AppendLine($"                        DefaultValue = {param.DefaultValue ?? "null"},");
                sb.AppendLine($"                        Constraint = {GenerateConstraintInstance(param.Constraint)},");
                sb.AppendLine($"                        Description = {(param.Description != null ? $"\"{param.Description}\"" : "null")}");
                sb.AppendLine("                    },");
            }

            sb.AppendLine("                }.ToFrozenDictionary(),");
            sb.AppendLine($"                RequiredParameters = new[] {{ {string.Join(", ", route.QueryMetadata?.RequiredParameters.Select(p => $"\"{p}\"") ?? Enumerable.Empty<string>())} }}.ToFrozenSet()");
            sb.AppendLine("            };");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static string GenerateConstraintInstance(RouteConstraintInfo? constraint)
    {
        if (constraint == null) return "null";

        return constraint.Type switch
        {
            "Range" => $"new RangeConstraint<int> {{ Min = {constraint.Min}, Max = {constraint.Max} }}",
            "Regex" => $"new RegexConstraint(\"{constraint.Pattern}\")",
            "Length" => $"new LengthConstraint {{ MinLength = {constraint.Min}, MaxLength = {constraint.Max} }}",
            "Enum" => $"new EnumConstraint<{constraint.ParameterName}>>()",
            "AllowedValues" => $"new AllowedValuesConstraint(\"{string.Join("\", \"", constraint.AllowedValues)}\")",
            _ => "null"
        };
    }

    private static void GenerateRouteEndpoints(StringBuilder sb, ImmutableArray<AdvancedRouteInfo> routes)
    {
        sb.AppendLine("    public static readonly FrozenSet<RouteEndpoint> Endpoints = new RouteEndpoint[]");
        sb.AppendLine("    {");

        foreach (var route in routes)
        {
            sb.AppendLine("        new RouteEndpoint(");
            sb.AppendLine($"            \"{route.Template}\",");
            sb.AppendLine($"            typeof({route.FullTypeName}),");
            sb.AppendLine($"            HttpMethod.{route.HttpMethod},");
            sb.AppendLine($"            {GenerateVersionInstance(route.Version)},");
            sb.AppendLine($"            {GenerateConstraintsInstance(route.Constraints)},");
            sb.AppendLine($"            {GenerateMetadataInstance(route.Metadata)}");
            sb.AppendLine("        ),");
        }

        sb.AppendLine("    }.ToFrozenSet();");
        sb.AppendLine();
    }

    private static string GenerateVersionInstance(ApiVersionInfo? version)
    {
        if (version == null) return "null";

        var status = version.Status != null ? $"\"{version.Status}\"" : "null";
        return $"new ApiVersion({version.Major}, {version.Minor}, {status})";
    }

    private static string GenerateConstraintsInstance(ImmutableArray<RouteConstraintInfo> constraints)
    {
        if (constraints.IsEmpty)
        {
            return "FrozenDictionary<string, IRouteConstraint>.Empty";
        }

        var sb = new StringBuilder();
        sb.AppendLine("new Dictionary<string, IRouteConstraint>");
        sb.AppendLine("            {");

        foreach (var constraint in constraints)
        {
            sb.AppendLine($"                [\"{constraint.ParameterName}\"] = {GenerateConstraintInstance(constraint)},");
        }

        sb.AppendLine("            }.ToFrozenDictionary()");

        return sb.ToString();
    }

    private static string GenerateMetadataInstance(ImmutableDictionary<string, object> metadata)
    {
        if (metadata.IsEmpty)
        {
            return "FrozenDictionary<string, object>.Empty";
        }

        var sb = new StringBuilder();
        sb.AppendLine("new Dictionary<string, object>");
        sb.AppendLine("            {");

        foreach (var kvp in metadata)
        {
            var key = kvp.Key;
            var value = kvp.Value;
            sb.AppendLine($"                [\"{key}\"] = \"{value}\",");
        }

        sb.AppendLine("            }.ToFrozenDictionary()");

        return sb.ToString();
    }

    private static void GenerateVersionedRoutes(StringBuilder sb, ImmutableArray<AdvancedRouteInfo> routes)
    {
        var versionedRoutes = routes.Where(r => r.Version != null).ToArray();
        if (!versionedRoutes.Any()) return;

        sb.AppendLine("    public static class VersionedRoutes");
        sb.AppendLine("    {");

        var groupedByVersion = versionedRoutes.GroupBy(r => $"v{r.Version!.Major}.{r.Version.Minor}");

        foreach (var versionGroup in groupedByVersion)
        {
            sb.AppendLine($"        public static readonly FrozenSet<RouteEndpoint> {versionGroup.Key.Replace(".", "_")} = new RouteEndpoint[]");
            sb.AppendLine("        {");

            foreach (var route in versionGroup)
            {
                sb.AppendLine($"            Endpoints.First(e => e.EndpointType == typeof({route.FullTypeName})),");
            }

            sb.AppendLine("        }.ToFrozenSet();");
            sb.AppendLine();
        }

        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void GenerateAlternativeRoutes(StringBuilder sb, ImmutableArray<AdvancedRouteInfo> routes)
    {
        var alternativeRoutes = routes.Where(r => r.HasAlternatives).ToArray();
        if (!alternativeRoutes.Any()) return;

        sb.AppendLine("    public static class AlternativeRoutes");
        sb.AppendLine("    {");

        foreach (var route in alternativeRoutes)
        {
            sb.AppendLine($"        public static readonly FrozenSet<string> {route.TypeName}Alternatives = new[]");
            sb.AppendLine("        {");

            foreach (var alternative in route.AlternativeTemplates)
            {
                sb.AppendLine($"            \"{alternative}\",");
            }

            sb.AppendLine("        }.ToFrozenSet();");
            sb.AppendLine();
        }

        sb.AppendLine("    }");
        sb.AppendLine();
    }
}