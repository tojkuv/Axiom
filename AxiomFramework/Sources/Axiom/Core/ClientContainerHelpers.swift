import Foundation

// MARK: - Client Container Simplification

/// Protocol for automatic client container generation
public protocol AutoClientContainer: ClientDependencies {
    /// Automatically generated initializer based on client properties
    init(clients: Any...)
}

/// Utility for creating client containers without boilerplate
public struct ClientContainerFactory {
    
    /// Create a single-client container
    public static func single<T: AxiomClient>(_ client: T) -> SingleClientDependencies<T> {
        SingleClientDependencies(client: client)
    }
    
    /// Create a two-client container
    public static func dual<T1: AxiomClient, T2: AxiomClient>(
        _ client1: T1,
        _ client2: T2
    ) -> DualClientDependencies<T1, T2> {
        DualClientDependencies(client1: client1, client2: client2)
    }
    
    /// Create a three-client container
    public static func triple<T1: AxiomClient, T2: AxiomClient, T3: AxiomClient>(
        _ client1: T1,
        _ client2: T2,
        _ client3: T3
    ) -> TripleClientDependencies<T1, T2, T3> {
        TripleClientDependencies(client1: client1, client2: client2, client3: client3)
    }
}

// MARK: - Pre-built Client Containers

/// Container for contexts with a single client
public struct SingleClientDependencies<T: AxiomClient>: ClientDependencies {
    public let client: T
    
    public init(client: T) {
        self.client = client
    }
    
    public init() {
        fatalError("SingleClientDependencies requires client instance")
    }
}

/// Container for contexts with two clients
public struct DualClientDependencies<T1: AxiomClient, T2: AxiomClient>: ClientDependencies {
    public let client1: T1
    public let client2: T2
    
    public init(client1: T1, client2: T2) {
        self.client1 = client1
        self.client2 = client2
    }
    
    public init() {
        fatalError("DualClientDependencies requires client instances")
    }
}

/// Container for contexts with three clients
public struct TripleClientDependencies<T1: AxiomClient, T2: AxiomClient, T3: AxiomClient>: ClientDependencies {
    public let client1: T1
    public let client2: T2
    public let client3: T3
    
    public init(client1: T1, client2: T2, client3: T3) {
        self.client1 = client1
        self.client2 = client2
        self.client3 = client3
    }
    
    public init() {
        fatalError("TripleClientDependencies requires client instances")
    }
}

// MARK: - Convenience Extensions

extension SingleClientDependencies {
    /// Access the single client directly
    public var primary: T { client }
}

extension DualClientDependencies {
    /// Access clients by position
    public var primary: T1 { client1 }
    public var secondary: T2 { client2 }
}

extension TripleClientDependencies {
    /// Access clients by position
    public var primary: T1 { client1 }
    public var secondary: T2 { client2 }
    public var tertiary: T3 { client3 }
}

// MARK: - Client Collection Utilities

/// Type-erased client collection for dynamic scenarios
public struct ClientCollection: ClientDependencies {
    private let clients: [String: any AxiomClient]
    
    public init(_ clients: [String: any AxiomClient]) {
        self.clients = clients
    }
    
    public init() {
        self.clients = [:]
    }
    
    /// Get a client by name and type
    public func client<T: AxiomClient>(named: String, as type: T.Type) -> T? {
        clients[named] as? T
    }
    
    /// Get all clients of a specific type
    public func clients<T: AxiomClient>(ofType type: T.Type) -> [T] {
        clients.values.compactMap { $0 as? T }
    }
}

// MARK: - Builder Pattern for Client Dependencies

/// Fluent builder for client dependencies
public final class ClientDependencyBuilder {
    private var clients: [String: any AxiomClient] = [:]
    
    /// Add a named client
    public func add<T: AxiomClient>(_ client: T, named: String) -> Self {
        clients[named] = client
        return self
    }
    
    /// Add a client with automatic naming based on type
    public func add<T: AxiomClient>(_ client: T) -> Self {
        let name = String(describing: T.self)
        clients[name] = client
        return self
    }
    
    /// Build the client collection
    public func build() -> ClientCollection {
        ClientCollection(clients)
    }
}

// MARK: - Automatic Client Container Generation

/// Marker protocol for contexts that want automatic client container generation
public protocol AutoGeneratedClients {
    associatedtype GeneratedClients: ClientDependencies
    static func generateClients(from clients: [any AxiomClient]) -> GeneratedClients
}

/// Default implementation for auto-generated client containers
extension AutoGeneratedClients {
    public static func generateClients(from clients: [any AxiomClient]) -> GeneratedClients {
        // This would use reflection or code generation to create the appropriate container
        fatalError("Auto-generation not implemented for \(Self.self)")
    }
}

// MARK: - Common Client Patterns

/// Pre-built container for CRUD operations
public struct CRUDClientDependencies<
    CreateClient: AxiomClient,
    ReadClient: AxiomClient,
    UpdateClient: AxiomClient,
    DeleteClient: AxiomClient
>: ClientDependencies {
    
    public let createClient: CreateClient
    public let readClient: ReadClient
    public let updateClient: UpdateClient
    public let deleteClient: DeleteClient
    
    public init(
        create: CreateClient,
        read: ReadClient,
        update: UpdateClient,
        delete: DeleteClient
    ) {
        self.createClient = create
        self.readClient = read
        self.updateClient = update
        self.deleteClient = delete
    }
    
    public init() {
        fatalError("CRUDClientDependencies requires all CRUD clients")
    }
}

/// Pre-built container for network + cache pattern
public struct NetworkCacheClientDependencies<
    NetworkClient: AxiomClient,
    CacheClient: AxiomClient
>: ClientDependencies {
    
    public let networkClient: NetworkClient
    public let cacheClient: CacheClient
    
    public init(network: NetworkClient, cache: CacheClient) {
        self.networkClient = network
        self.cacheClient = cache
    }
    
    public init() {
        fatalError("NetworkCacheClientDependencies requires network and cache clients")
    }
}

// MARK: - Client Validation

/// Utility for validating client dependencies at runtime
public struct ClientDependencyValidator {
    
    /// Validate that all required clients are present and properly configured
    public static func validate<T: ClientDependencies>(_ dependencies: T) async throws {
        // Use reflection to find all client properties and validate them
        print("üîç Validating client dependencies for \(type(of: dependencies))")
        
        // This would implement actual validation logic
        // For now, just a placeholder
    }
    
    /// Check if a client dependency container has all required clients
    public static func isComplete<T: ClientDependencies>(_ dependencies: T) -> Bool {
        // Implementation would check all client properties are non-nil and initialized
        return true // Placeholder
    }
}